from typing import Callable, Dict, List, Optional, Tuple, Union
from uuid import UUID

import torch

# torch is a "hidden dependency" i think - like installing rust_circuit doesn't install it
# but we crash without it. We could make it a visible dependency

Shape = Tuple[int, ...]

class EinsumSpec(object):
    input_ints: List[List[int]]
    output_ints: List[int]
    int_sizes: List[int]
    def __init__(self, input_ints: List[List[int]], output_ints: List[int], int_sizes: Dict[int, int]): ...
    def flops(self) -> int: ...
    def optimize_dp(
        self, check_outer: bool, mem_limit: Optional[int], hash_limit: Optional[int]
    ) -> List[List[int]]: ...
    def normalize(self) -> "EinsumSpec": ...
    def validate(self) -> bool: ...
    def shapes(self) -> Tuple[List[List[int]], List[int]]: ...
    def to_einsum_string(self) -> str: ...

class RearrangeSpec(object):
    input_ints: List[List[int]]
    output_ints: List[List[int]]
    int_sizes: List[Optional[int]]
    def __init__(self, input_ints: List[List[int]], output_ints: List[List[int]], int_sizes: List[Optional[int]]): ...
    def is_identity(self, special_case_ones: bool) -> bool: ...
    def is_permute(self) -> bool: ...
    def shapes(self) -> Tuple[List[int], List[int]]: ...
    def is_valid(self) -> bool: ...
    def to_einops_string(self) -> str: ...
    def to_einops_string_and_letter_sizes(self) -> Tuple[str, List[Tuple[str, int]]]: ...
    def apply(self, tensor: torch.Tensor) -> torch.Tensor: ...

class Circuit:
    @property
    def shape(self) -> Shape: ...
    @property
    def is_constant(self) -> bool: ...
    @property
    def is_explicitly_computable(self) -> bool: ...
    @property
    def can_be_sampled(self) -> bool: ...
    @property
    def name(self) -> str: ...
    def children(self) -> List[Circuit]: ...
    def self_flops(self) -> int: ...
    def apply_fn_to_sub(self, f: Callable[[Circuit], Circuit]) -> Circuit: ...
    def compiler_print(self) -> None: ...
    def compiler_repr(self) -> str: ...
    def numel(self) -> int: ...
    def rank(self) -> int: ...

class ArrayConstant(Circuit):
    def __init__(self, value: torch.Tensor, name: str = "ArrayConstant") -> None: ...
    @property
    def uuid(self) -> UUID: ...
    @property
    def value(self) -> torch.Tensor: ...

class Symbol(Circuit):
    def __init__(self, shape: Shape, uuid: UUID, name: str = "Symbol") -> None: ...
    @property
    def uuid(self) -> UUID: ...

class ScalarConstant(Circuit):
    def __init__(self, value: float, shape: Shape = (), name: str = "ScalarConstant") -> None: ...
    @property
    def value(self) -> float: ...
    def is_zero(self) -> bool: ...
    def is_one(self) -> bool: ...

class Einsum(Circuit):
    def __init__(
        self, *args: Tuple[Circuit, Tuple[int, ...]], out_axes: Tuple[int, ...], name: Optional[str] = None
    ) -> None: ...
    @property
    def args(self) -> List[Tuple[Circuit, Tuple[int, ...]]]: ...
    @property
    def out_axes(self) -> Tuple[int, ...]: ...
    def flatten_once(self) -> Einsum: ...
    def all_input_circuits(self) -> List[Circuit]: ...
    def all_input_axes(self) -> List[Tuple[int, ...]]: ...

class Add(Circuit):
    def __init__(self, nodes: List[Circuit], name: Optional[str] = None) -> None: ...
    @property
    def nodes(self) -> List[Circuit]: ...
    def flatten_once(self) -> Add: ...
    def deduplicate(self) -> Add: ...
    def collapse_scalar_inputs(self) -> Add: ...
    def elim_few(self) -> Circuit: ...
    def common_rearrange_after(self) -> Circuit: ...

class Rearrange(Circuit):
    def __init__(self, node: Circuit, spec: RearrangeSpec, name: Optional[str] = None) -> None: ...
    @property
    def node(self) -> Circuit: ...
    @property
    def spec(self) -> RearrangeSpec: ...

class Index(Circuit):
    def __init__(
        self, node: Circuit, index: Tuple[Union[int, slice, torch.Tensor], ...], name: Optional[str] = None
    ) -> None: ...
    @property
    def node(self) -> Circuit: ...
    @property
    def index(self) -> Tuple[Union[int, slice, torch.Tensor], ...]: ...

class GeneralFunctionSpec(object):
    function: Callable
    get_shape: Callable
    get_jacobian: Optional[Callable]
    num_non_batchable_output_dims: int
    input_batchability: List[bool]
    name: str
    def __init__(
        self,
        function: Callable,
        get_shape: Callable,
        get_jacobian: Optional[Callable],
        num_non_batchable_output_dims: int,
        input_batchability: List[bool],
        name: str,
    ) -> None: ...

class GeneralFunction(Circuit):
    def __init__(self, nodes: List[Circuit], spec: GeneralFunctionSpec, name: Optional[str] = None) -> None: ...
    @property
    def nodes(self) -> List[Circuit]: ...
    @property
    def spec(self) -> GeneralFunctionSpec: ...

class Concat(Circuit):
    def __init__(self, nodes: List[Circuit], axis: int, name: Optional[str] = None) -> None: ...
    @property
    def nodes(self) -> List[Circuit]: ...
    @property
    def axis(self) -> int: ...

def collapse_add_scalar_inputs(add: Add) -> Optional[Add]: ...
def add_deduplicate(add: Add) -> Optional[Add]: ...
def add_flatten_once(add: Add) -> Optional[Add]: ...
def remove_add_few_input(add: Add) -> Optional[Add]: ...
def common_rearrange_after_add(add: Add) -> Optional[Add]: ...
def einsum_flatten_once(einsum: Einsum) -> Optional[Einsum]: ...
