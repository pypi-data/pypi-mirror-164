{"version":3,"file":"lib_index_js.969da09a6a07272b33b5.js","mappings":";;;;;;;;;;;;;;;;;AAA+C;AACS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACO,kDAAkD;AACzD;AACA,qBAAqB,+EAA6B;AAClD,uBAAuB,8DAAW;AAClC;AACA;AACA;AACA,yBAAyB,8EAA4B;AACrD;AACA;AACA,kBAAkB,+EAA6B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gFAA8B;AAChD;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AClCwD;AACd;AACsF;AACzF;AACmB;AAC1D;AACO,kDAAkD,oDAAK;AAC9D;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA,aAAa,eAAe;AAC5B,mBAAmB,mEAA6B,GAAG,qCAAqC;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kEAAgB;AAC/B,eAAe,0IAAmC;AAClD;AACA,8BAA8B,oDAAU;AACxC,uBAAuB,UAAU,IAAI,QAAQ;AAC7C,6BAA6B,oDAAU;AACvC,8FAA8F,gBAAgB;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF,8BAA8B;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,eAAe;AAClF,+FAA+F,eAAe;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,iEAAe,MAAM,EAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjEiC;AACZ;AACJ;AAChC;AACP,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iCAAiC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,WAAW;AACpC;AACA;AACA;AACA;AACO;AACP,kBAAkB,uBAAuB;AACzC,4CAA4C,qDAAM;AAClD,yCAAyC,qDAAM;AAC/C,4CAA4C,qDAAM;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mEAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,kBAAkB,uBAAuB;AACzC;AACA,oCAAoC,qDAAM;AAC1C,mCAAmC,qDAAM;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,QAAQ,mEAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,kBAAkB,uBAAuB;AACzC,mCAAmC,qDAAM;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,QAAQ,mEAAoB;AAC5B;AACA;AACA,mEAAmE,iCAAiC;AACpG;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACO;AACP,kBAAkB,uBAAuB;AACzC,kCAAkC,qDAAM;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,QAAQ,mEAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oDAAoD;AAChF;AACA;AACA,iCAAiC,0BAA0B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACO;AACP,kBAAkB,uBAAuB;AACzC,iCAAiC,qDAAM;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kFAAgC;AACpD;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,QAAQ,mEAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACO;AACP,kBAAkB,uBAAuB;AACzC;AACA,qCAAqC,qDAAM;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,QAAQ,mEAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACO;AACP,kBAAkB,uBAAuB;AACzC,sCAAsC,qDAAM;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,QAAQ,mEAAoB;AAC5B;AACA;AACA;AACA,8EAA8E;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACO;AACP,kBAAkB,uBAAuB;AACzC,mCAAmC,qDAAM;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,QAAQ,mEAAoB;AAC5B;AACA;AACA,mEAAmE,iCAAiC;AACpG;AACA;AACA;AACA;AACA,2BAA2B,oDAAU;AACrC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACO;AACP,kBAAkB,uBAAuB;AACzC,8BAA8B,qDAAM;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,QAAQ,mEAAoB;AAC5B;AACA;AACA;AACA,2BAA2B,gDAAgD;AAC3E;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACO;AACP,kBAAkB,uBAAuB;AACzC,gCAAgC,qDAAM;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,QAAQ,mEAAoB;AAC5B;AACA;AACA;AACA,2BAA2B,gDAAgD;AAC3E;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACO;AACP,kBAAkB,uBAAuB;AACzC,gCAAgC,qDAAM;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kFAAgC;AACpD;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,QAAQ,mEAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA","sources":["webpack://@educational-technology-collective/etc_jupyterlab_telemetry_library/./lib/handler.js","webpack://@educational-technology-collective/etc_jupyterlab_telemetry_library/./lib/index.js","webpack://@educational-technology-collective/etc_jupyterlab_telemetry_library/./lib/library.js"],"sourcesContent":["import { URLExt } from '@jupyterlab/coreutils';\nimport { ServerConnection } from '@jupyterlab/services';\n/**\n * Call the API extension\n *\n * @param endPoint API REST end point for the extension\n * @param init Initial values for the request\n * @returns The response body interpreted as JSON\n */\nexport async function requestAPI(endPoint = '', init = {}) {\n    // Make request to Jupyter API\n    const settings = ServerConnection.makeSettings();\n    const requestUrl = URLExt.join(settings.baseUrl, 'etc-jupyterlab-telemetry-library', // API Namespace\n    endPoint);\n    let response;\n    try {\n        response = await ServerConnection.makeRequest(requestUrl, init, settings);\n    }\n    catch (error) {\n        throw new ServerConnection.NetworkError(error);\n    }\n    let data = await response.text();\n    if (data.length > 0) {\n        try {\n            data = JSON.parse(data);\n        }\n        catch (error) {\n            console.log('Not a JSON response body.', response);\n        }\n    }\n    if (!response.ok) {\n        throw new ServerConnection.ResponseError(response, data.message || data);\n    }\n    return data;\n}\n","import { INotebookTracker } from '@jupyterlab/notebook';\nimport { Token } from '@lumino/coreutils';\nimport { IETCJupyterLabNotebookStateProvider } from \"@educational-technology-collective/etc_jupyterlab_notebook_state_provider\";\nimport { requestAPI } from \"./handler\";\nimport { ETCJupyterLabTelemetryLibrary } from './library';\nconst PLUGIN_ID = '@educational-technology-collective/etc_jupyterlab_telemetry_library:plugin';\nexport const IETCJupyterLabTelemetryLibraryFactory = new Token(PLUGIN_ID);\nclass ETCJupyterLabTelemetryLibraryFactory {\n    constructor({ config }) {\n        this._config = config;\n    }\n    create({ notebookPanel }) {\n        return new ETCJupyterLabTelemetryLibrary({ notebookPanel, config: this._config });\n    }\n}\n/**\n * Initialization data for the @educational-technology-collective/etc_jupyterlab_telemetry_extension extension.\n */\nconst plugin = {\n    id: PLUGIN_ID,\n    autoStart: true,\n    provides: IETCJupyterLabTelemetryLibraryFactory,\n    requires: [INotebookTracker],\n    optional: [IETCJupyterLabNotebookStateProvider],\n    activate: async (app, notebookTracker, etcJupyterLabNotebookStateProvider) => {\n        const VERSION = await requestAPI(\"version\");\n        console.log(`${PLUGIN_ID}, ${VERSION}`);\n        const CONFIG = await requestAPI(\"config\");\n        let etcJupyterLabTelemetryLibraryFactory = new ETCJupyterLabTelemetryLibraryFactory({ config: CONFIG });\n        // // TEST\n        // class MessageAdapter {\n        //   constructor() { }\n        //   log(sender: any, args: any) {\n        //     let notebookPanel = args.notebookPanel;\n        //     delete args.notebookPanel;\n        //     let notebookState = etcJupyterLabNotebookStateProvider.getNotebookState({ notebookPanel: notebookPanel })\n        //     let data = {\n        //       ...args, ...notebookState\n        //     }\n        //     console.log(\"etc_jupyterlab_telemetry_extension\", data);\n        //   }\n        // }\n        // let messageAdapter = new MessageAdapter();\n        // notebookTracker.widgetAdded.connect(async (sender: INotebookTracker, notebookPanel: NotebookPanel) => {\n        //   etcJupyterLabNotebookStateProvider.addNotebookPanel({ notebookPanel });\n        //   let etcJupyterLabTelemetryLibrary = etcJupyterLabTelemetryLibraryFactory.create({ notebookPanel });\n        //   etcJupyterLabTelemetryLibrary.notebookClipboardEvent.notebookClipboardCopied.connect(messageAdapter.log);\n        //   etcJupyterLabTelemetryLibrary.notebookClipboardEvent.notebookClipboardCut.connect(messageAdapter.log);\n        //   etcJupyterLabTelemetryLibrary.notebookClipboardEvent.notebookClipboardPasted.connect(messageAdapter.log);\n        //   etcJupyterLabTelemetryLibrary.notebookVisibilityEvent.notebookVisible.connect(messageAdapter.log);\n        //   etcJupyterLabTelemetryLibrary.notebookVisibilityEvent.notebookHidden.connect(messageAdapter.log);\n        //   etcJupyterLabTelemetryLibrary.notebookOpenEvent.notebookOpened.connect(messageAdapter.log);\n        //   etcJupyterLabTelemetryLibrary.notebookCloseEvent.notebookClosed.connect(messageAdapter.log);\n        //   etcJupyterLabTelemetryLibrary.notebookSaveEvent.notebookSaved.connect(messageAdapter.log);\n        //   etcJupyterLabTelemetryLibrary.notebookScrollEvent.notebookScrolled.connect(messageAdapter.log);\n        //   etcJupyterLabTelemetryLibrary.activeCellChangeEvent.activeCellChanged.connect(messageAdapter.log);\n        //   etcJupyterLabTelemetryLibrary.cellAddEvent.cellAdded.connect(messageAdapter.log);\n        //   etcJupyterLabTelemetryLibrary.cellRemoveEvent.cellRemoved.connect(messageAdapter.log);\n        //   etcJupyterLabTelemetryLibrary.cellExecutionEvent.cellExecuted.connect(messageAdapter.log);\n        //   etcJupyterLabTelemetryLibrary.cellErrorEvent.cellErrored.connect(messageAdapter.log);\n        // });\n        // // TEST\n        return etcJupyterLabTelemetryLibraryFactory;\n    }\n};\nexport default plugin;\n","import { NotebookActions } from '@jupyterlab/notebook';\nimport { Signal } from '@lumino/signaling';\nimport { requestAPI } from './handler';\nexport class ETCJupyterLabTelemetryLibrary {\n    constructor({ notebookPanel, config }) {\n        this.notebookClipboardEvent = new NotebookClipboardEvent({\n            notebookPanel: notebookPanel,\n            config: config\n        });\n        this.notebookVisibilityEvent = new NotebookVisibilityEvent({\n            notebookPanel: notebookPanel,\n            config: config\n        });\n        this.notebookCloseEvent = new NotebookCloseEvent({\n            notebookPanel: notebookPanel,\n            config: config\n        });\n        this.notebookOpenEvent = new NotebookOpenEvent({\n            notebookPanel: notebookPanel,\n            config: config\n        });\n        this.notebookSaveEvent = new NotebookSaveEvent({\n            notebookPanel: notebookPanel,\n            config: config\n        });\n        this.cellExecutionEvent = new CellExecutionEvent({\n            notebookPanel: notebookPanel,\n            config: config\n        });\n        this.cellErrorEvent = new CellErrorEvent({\n            notebookPanel: notebookPanel,\n            config: config\n        });\n        this.notebookScrollEvent = new NotebookScrollEvent({\n            notebookPanel: notebookPanel,\n            config: config\n        });\n        this.activeCellChangeEvent = new ActiveCellChangeEvent({\n            notebookPanel: notebookPanel,\n            config: config\n        });\n        this.cellAddEvent = new CellAddEvent({\n            notebookPanel: notebookPanel,\n            config: config\n        });\n        this.cellRemoveEvent = new CellRemoveEvent({\n            notebookPanel: notebookPanel,\n            config: config\n        });\n    }\n}\nclass NotebookEvent {\n    constructor(notebookPanel) {\n        this._notebookPanel = notebookPanel;\n    }\n    getVisibleCells() {\n        let cells = [];\n        let cell;\n        let index;\n        let id;\n        let notebook = this._notebookPanel.content;\n        for (index = 0; index < notebook.widgets.length; index++) {\n            cell = notebook.widgets[index];\n            let cellTop = cell.node.offsetTop;\n            let cellBottom = cell.node.offsetTop + cell.node.offsetHeight;\n            let viewTop = notebook.node.scrollTop;\n            let viewBottom = notebook.node.scrollTop + notebook.node.clientHeight;\n            if (cellTop > viewBottom || cellBottom < viewTop) {\n                continue;\n            }\n            id = cell.model.id;\n            cells.push({ id, index });\n        }\n        return cells;\n    }\n}\nexport class NotebookClipboardEvent {\n    constructor({ notebookPanel, config }) {\n        this._notebookClipboardCopied = new Signal(this);\n        this._notebookClipboardCut = new Signal(this);\n        this._notebookClipboardPasted = new Signal(this);\n        this._notebookPanel = notebookPanel;\n        this._notebook = notebookPanel.content;\n        this.handleCopy = this.handleCopy.bind(this);\n        this.handleCut = this.handleCut.bind(this);\n        this.handlePaste = this.handlePaste.bind(this);\n        notebookPanel.disposed.connect(this.onDisposed, this);\n        if (config.notebook_clipboard_event) {\n            this._notebookPanel.node.addEventListener('copy', this.handleCopy, false);\n            this._notebookPanel.node.addEventListener('cut', this.handleCut, false);\n            this._notebookPanel.node.addEventListener('paste', this.handlePaste, false);\n        }\n    }\n    onDisposed() {\n        Signal.disconnectAll(this);\n        this._notebookPanel.node.removeEventListener('copy', this.handleCopy, false);\n        this._notebookPanel.node.removeEventListener('cut', this.handleCut, false);\n        this._notebookPanel.node.removeEventListener('paste', this.handlePaste, false);\n    }\n    handleCopy(event) {\n        var _a;\n        let text = (_a = document.getSelection()) === null || _a === void 0 ? void 0 : _a.toString();\n        let cell = this._notebookPanel.content.activeCell;\n        let cells = [\n            {\n                id: cell === null || cell === void 0 ? void 0 : cell.model.id,\n                index: this._notebook.widgets.findIndex((value) => value == cell)\n            }\n        ];\n        this._notebookClipboardCopied.emit({\n            eventName: 'clipboard_copy',\n            cells: cells,\n            notebookPanel: this._notebookPanel,\n            selection: text\n        });\n    }\n    handleCut(event) {\n        var _a;\n        let text = (_a = document.getSelection()) === null || _a === void 0 ? void 0 : _a.toString();\n        let cell = this._notebookPanel.content.activeCell;\n        let cells = [\n            {\n                id: cell === null || cell === void 0 ? void 0 : cell.model.id,\n                index: this._notebook.widgets.findIndex((value) => value == cell)\n            }\n        ];\n        this._notebookClipboardCut.emit({\n            eventName: 'clipboard_cut',\n            cells: cells,\n            notebookPanel: this._notebookPanel,\n            selection: text\n        });\n    }\n    handlePaste(event) {\n        let text = (event.clipboardData || window.clipboardData).getData('text');\n        let cell = this._notebookPanel.content.activeCell;\n        let cells = [\n            {\n                id: cell === null || cell === void 0 ? void 0 : cell.model.id,\n                index: this._notebook.widgets.findIndex((value) => value == cell)\n            }\n        ];\n        this._notebookClipboardPasted.emit({\n            eventName: 'clipboard_paste',\n            cells: cells,\n            notebookPanel: this._notebookPanel,\n            selection: text\n        });\n    }\n    get notebookClipboardCopied() {\n        return this._notebookClipboardCopied;\n    }\n    get notebookClipboardCut() {\n        return this._notebookClipboardCut;\n    }\n    get notebookClipboardPasted() {\n        return this._notebookClipboardPasted;\n    }\n}\nexport class NotebookVisibilityEvent extends NotebookEvent {\n    constructor({ notebookPanel, config }) {\n        super(notebookPanel);\n        this._notebookVisible = new Signal(this);\n        this._notebookHidden = new Signal(this);\n        this._hiddenProperty = 'hidden';\n        this._visibilityChange = 'visibilitychange';\n        this._visibility = false;\n        this._notebookPanel = notebookPanel;\n        let notebook = this._notebook = notebookPanel.content;\n        this.handleVisibilityChange = this.handleVisibilityChange.bind(this);\n        this.handleFocus = this.handleFocus.bind(this);\n        this.handleBlur = this.handleBlur.bind(this);\n        notebookPanel.disposed.connect(this.onDisposed, this);\n        if (config.notebook_visibility_event) {\n            (async () => {\n                try {\n                    await notebookPanel.revealed;\n                    if (typeof document.hidden !== 'undefined') {\n                        this._hiddenProperty = 'hidden';\n                        this._visibilityChange = 'visibilitychange';\n                    }\n                    else if (typeof document.msHidden !== 'undefined') {\n                        this._hiddenProperty = 'msHidden';\n                        this._visibilityChange = 'msvisibilitychange';\n                    }\n                    else if (typeof document.webkitHidden !== 'undefined') {\n                        this._hiddenProperty = 'webkitHidden';\n                        this._visibilityChange = 'webkitvisibilitychange';\n                    }\n                    document.addEventListener(this._visibilityChange, this.handleVisibilityChange, false);\n                    notebook.node.addEventListener('blur', this.handleBlur, true);\n                    notebook.node.addEventListener('focus', this.handleFocus, true);\n                    window.addEventListener('blur', this.handleBlur, true);\n                    window.addEventListener('focus', this.handleFocus, true);\n                    this.visibility = notebookPanel.content.isVisible;\n                }\n                catch (e) {\n                    console.error(e);\n                }\n            })();\n        }\n    }\n    onDisposed() {\n        Signal.disconnectAll(this);\n        document.removeEventListener(this._visibilityChange, this.handleVisibilityChange, false);\n        this._notebook.node.removeEventListener('blur', this.handleBlur, true);\n        this._notebook.node.removeEventListener('focus', this.handleFocus, true);\n        window.removeEventListener('blur', this.handleBlur, true);\n        window.removeEventListener('focus', this.handleFocus, true);\n    }\n    handleVisibilityChange(event) {\n        this.visibility = !document[this._hiddenProperty] && this._notebook.isVisible;\n    }\n    handleBlur(event) {\n        if (event.currentTarget === window && event.target === window) {\n            this.visibility = false;\n        }\n        else if (event.currentTarget === this._notebook.node) {\n            this.visibility = this._notebook.isVisible;\n        }\n    }\n    handleFocus(event) {\n        this.visibility = this._notebook.isVisible;\n    }\n    set visibility(visibility) {\n        if (this._visibility != visibility) {\n            this._visibility = visibility;\n            let cells = this.getVisibleCells();\n            if (this._visibility === true) {\n                this._notebookVisible.emit({\n                    eventName: 'notebook_visible',\n                    cells: cells,\n                    notebookPanel: this._notebookPanel\n                });\n            }\n            else if (this._visibility === false) {\n                this._notebookHidden.emit({\n                    eventName: 'notebook_hidden',\n                    cells: cells,\n                    notebookPanel: this._notebookPanel\n                });\n            }\n        }\n    }\n    get notebookVisible() {\n        return this._notebookVisible;\n    }\n    get notebookHidden() {\n        return this._notebookHidden;\n    }\n}\nexport class NotebookCloseEvent {\n    constructor({ notebookPanel, config }) {\n        this._notebookClosed = new Signal(this);\n        this._notebookPanel = notebookPanel;\n        this._notebook = notebookPanel.content;\n        if (config.notebook_close_event) {\n            (async () => {\n                try {\n                    await notebookPanel.revealed;\n                    notebookPanel.disposed.connect(this.onNotebookDisposed, this);\n                    notebookPanel.disposed.connect(this.onDisposed, this);\n                }\n                catch (e) {\n                    console.error(e);\n                }\n            })();\n        }\n    }\n    onDisposed() {\n        Signal.disconnectAll(this);\n    }\n    onNotebookDisposed() {\n        let cells = this._notebook.widgets.map((cell, index) => ({ id: cell.model.id, index: index }));\n        this._notebookClosed.emit({\n            eventName: 'close_notebook',\n            cells: cells,\n            notebookPanel: this._notebookPanel\n        });\n    }\n    get notebookClosed() {\n        return this._notebookClosed;\n    }\n}\nexport class NotebookSaveEvent {\n    constructor({ notebookPanel, config }) {\n        this._notebookSaved = new Signal(this);\n        this._notebookPanel = notebookPanel;\n        notebookPanel.disposed.connect(this.onDisposed, this);\n        if (config.notebook_save_event) {\n            (async () => {\n                try {\n                    await notebookPanel.revealed;\n                    notebookPanel.context.saveState.connect(this.onSaveState, this);\n                }\n                catch (e) {\n                    console.error(e);\n                }\n            })();\n        }\n    }\n    onDisposed() {\n        Signal.disconnectAll(this);\n    }\n    onSaveState(context, saveState) {\n        let cell;\n        let cells;\n        let index;\n        if (saveState.match('completed')) {\n            cells = [];\n            for (index = 0; index < this._notebookPanel.content.widgets.length; index++) {\n                cell = this._notebookPanel.content.widgets[index];\n                if (this._notebookPanel.content.isSelectedOrActive(cell)) {\n                    cells.push({ id: cell.model.id, index });\n                }\n            }\n            this._notebookSaved.emit({\n                eventName: 'save_notebook',\n                cells: cells,\n                notebookPanel: this._notebookPanel\n            });\n        }\n    }\n    get notebookSaved() {\n        return this._notebookSaved;\n    }\n}\nexport class CellExecutionEvent {\n    constructor({ notebookPanel, config }) {\n        this._cellExecuted = new Signal(this);\n        this._notebookPanel = notebookPanel;\n        this._notebook = notebookPanel.content;\n        notebookPanel.disposed.connect(this.onDisposed, this);\n        if (config.notebook_cell_execution_event) {\n            (async () => {\n                try {\n                    await notebookPanel.revealed;\n                    NotebookActions.executed.connect(this.onExecuted, this);\n                }\n                catch (e) {\n                    console.error(e);\n                }\n            })();\n        }\n    }\n    onDisposed() {\n        Signal.disconnectAll(this);\n    }\n    onExecuted(_, args) {\n        if (args.notebook.model === this._notebook.model) {\n            let cells = [\n                {\n                    id: args.cell.model.id,\n                    index: this._notebook.widgets.findIndex((value) => value == args.cell)\n                }\n            ];\n            this._cellExecuted.emit({\n                eventName: 'cell_executed',\n                cells: cells,\n                notebookPanel: this._notebookPanel\n            });\n        }\n    }\n    get cellExecuted() {\n        return this._cellExecuted;\n    }\n}\nexport class NotebookScrollEvent extends NotebookEvent {\n    constructor({ notebookPanel, config }) {\n        super(notebookPanel);\n        this._notebookScrolled = new Signal(this);\n        this._notebookPanel = notebookPanel;\n        this._timeout = 0;\n        this.onScrolled = this.onScrolled.bind(this);\n        notebookPanel.disposed.connect(this.onDisposed, this);\n        if (config.notebook_scroll_event) {\n            (async () => {\n                try {\n                    await notebookPanel.revealed;\n                    notebookPanel.content.node.addEventListener('scroll', this.onScrolled, false);\n                }\n                catch (e) {\n                    console.error(e);\n                }\n            })();\n        }\n    }\n    onDisposed() {\n        Signal.disconnectAll(this);\n    }\n    onScrolled(e) {\n        e.stopPropagation();\n        clearTimeout(this._timeout);\n        this._timeout = setTimeout(() => {\n            let cells = this.getVisibleCells();\n            this._notebookScrolled.emit({\n                eventName: 'scroll',\n                cells: cells,\n                notebookPanel: this._notebookPanel\n            });\n        }, 1000);\n    }\n    get notebookScrolled() {\n        return this._notebookScrolled;\n    }\n}\nexport class ActiveCellChangeEvent {\n    constructor({ notebookPanel, config }) {\n        this._activeCellChanged = new Signal(this);\n        this._notebookPanel = notebookPanel;\n        this._notebook = notebookPanel.content;\n        notebookPanel.disposed.connect(this.onDisposed, this);\n        if (config.notebook_active_cell_change_event) {\n            (async () => {\n                try {\n                    await notebookPanel.revealed;\n                    notebookPanel.content.activeCellChanged.connect(this.onActiveCellChanged, this);\n                }\n                catch (e) {\n                    console.error(e);\n                }\n            })();\n        }\n    }\n    onDisposed() {\n        Signal.disconnectAll(this);\n    }\n    onActiveCellChanged(send, args) {\n        if (this._notebook.widgets.length > 1) {\n            //  More than 1 cell is needed in order for this event to happen; hence, check the number of cells.\n            let cells = [\n                {\n                    id: args.model.id,\n                    index: this._notebook.widgets.findIndex((value) => value == args)\n                }\n            ];\n            this._activeCellChanged.emit({\n                eventName: 'active_cell_changed',\n                cells: cells,\n                notebookPanel: this._notebookPanel\n            });\n        }\n    }\n    get activeCellChanged() {\n        return this._activeCellChanged;\n    }\n}\nexport class NotebookOpenEvent {\n    constructor({ notebookPanel, config }) {\n        this._notebookOpened = new Signal(this);\n        this._once = false;\n        this._notebookPanel = notebookPanel;\n        this._notebook = notebookPanel.content;\n        notebookPanel.disposed.connect(this.onDisposed, this);\n        if (config.notebook_open_event) {\n            if (!this._once) {\n                (async () => {\n                    try {\n                        await notebookPanel.revealed;\n                        await this.emitNotebookOpened();\n                    }\n                    catch (e) {\n                        console.error(e);\n                    }\n                })();\n            }\n        }\n    }\n    onDisposed() {\n        Signal.disconnectAll(this);\n    }\n    async emitNotebookOpened() {\n        let cells = this._notebook.widgets.map((cell, index) => ({ id: cell.model.id, index: index }));\n        this._notebookOpened.emit({\n            eventName: 'open_notebook',\n            cells: cells,\n            notebookPanel: this._notebookPanel,\n            environ: await requestAPI('environ')\n        });\n        this._once = true;\n    }\n    get notebookOpened() {\n        return this._notebookOpened;\n    }\n}\nexport class CellAddEvent {\n    constructor({ notebookPanel, config }) {\n        this._cellAdded = new Signal(this);\n        this._notebookPanel = notebookPanel;\n        notebookPanel.disposed.connect(this.onDisposed, this);\n        if (config.notebook_cell_add_event) {\n            (async () => {\n                var _a;\n                try {\n                    await notebookPanel.revealed;\n                    (_a = notebookPanel.content.model) === null || _a === void 0 ? void 0 : _a.cells.changed.connect(this.onCellsChanged, this);\n                }\n                catch (e) {\n                    console.error(e);\n                }\n            })();\n        }\n    }\n    onDisposed() {\n        Signal.disconnectAll(this);\n    }\n    onCellsChanged(sender, args) {\n        if (args.type == 'add') {\n            let cells = [{ id: args.newValues[0].id, index: args.newIndex }];\n            this._cellAdded.emit({\n                eventName: 'add_cell',\n                cells: cells,\n                notebookPanel: this._notebookPanel\n            });\n        }\n    }\n    get cellAdded() {\n        return this._cellAdded;\n    }\n}\nexport class CellRemoveEvent {\n    constructor({ notebookPanel, config }) {\n        this._cellRemoved = new Signal(this);\n        this._notebookPanel = notebookPanel;\n        notebookPanel.disposed.connect(this.onDisposed, this);\n        if (config.notebook_cell_remove_event) {\n            (async () => {\n                var _a;\n                try {\n                    await notebookPanel.revealed;\n                    (_a = notebookPanel.content.model) === null || _a === void 0 ? void 0 : _a.cells.changed.connect(this.onCellsChanged, this);\n                }\n                catch (e) {\n                    console.error(e);\n                }\n            })();\n        }\n    }\n    onDisposed() {\n        Signal.disconnectAll(this);\n    }\n    onCellsChanged(sender, args) {\n        if (args.type == 'remove') {\n            let cells = [{ id: args.oldValues[0].id, index: args.oldIndex }];\n            this._cellRemoved.emit({\n                eventName: 'remove_cell',\n                cells: cells,\n                notebookPanel: this._notebookPanel\n            });\n        }\n    }\n    get cellRemoved() {\n        return this._cellRemoved;\n    }\n}\nexport class CellErrorEvent {\n    constructor({ notebookPanel, config }) {\n        this._cellErrored = new Signal(this);\n        this._notebookPanel = notebookPanel;\n        notebookPanel.disposed.connect(this.onDisposed, this);\n        if (config.notebook_cell_error_event) {\n            (async () => {\n                try {\n                    await notebookPanel.revealed;\n                    NotebookActions.executed.connect(this.onExecuted, this);\n                }\n                catch (e) {\n                    console.error(e);\n                }\n            })();\n        }\n    }\n    onDisposed() {\n        Signal.disconnectAll(this);\n    }\n    onExecuted(_, args) {\n        if (!args.success || args.error) {\n            let cells = [\n                {\n                    id: args.cell.model.id,\n                    index: this._notebookPanel.content.widgets.findIndex((value) => value == args.cell)\n                }\n            ];\n            this._cellErrored.emit({\n                eventName: 'cell_errored',\n                cells: cells,\n                notebookPanel: this._notebookPanel,\n                kernelError: args.error\n            });\n        }\n    }\n    get cellErrored() {\n        return this._cellErrored;\n    }\n}\n"],"names":[],"sourceRoot":""}