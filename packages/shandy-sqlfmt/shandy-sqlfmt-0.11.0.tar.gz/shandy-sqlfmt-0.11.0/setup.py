# -*- coding: utf-8 -*-
from setuptools import setup

package_dir = \
{'': 'src'}

packages = \
['sqlfmt', 'sqlfmt_primer']

package_data = \
{'': ['*']}

install_requires = \
['click>=8.0,<9.0', 'platformdirs>=2.4.0,<3.0.0', 'tqdm>=4.0,<5.0']

extras_require = \
{':python_version < "3.11"': ['tomli>=2.0.1,<3.0.0'],
 ':python_version < "3.8"': ['importlib_metadata'],
 'jinjafmt': ['black'],
 'sqlfmt_primer': ['gitpython>=3.1.24,<4.0.0']}

entry_points = \
{'console_scripts': ['sqlfmt = sqlfmt.cli:sqlfmt',
                     'sqlfmt_primer = sqlfmt_primer.primer:sqlfmt_primer']}

setup_kwargs = {
    'name': 'shandy-sqlfmt',
    'version': '0.11.0',
    'description': 'sqlfmt is an opinionated CLI tool that formats your sql files',
    'long_description': '# sqlfmt\n\n![PyPI](https://img.shields.io/pypi/v/shandy-sqlfmt)\n[![Lint and Test](https://github.com/tconbeer/sqlfmt/actions/workflows/test.yml/badge.svg)](https://github.com/tconbeer/sqlfmt/actions/workflows/test.yml)\n\n![PyPI - Python Version](https://img.shields.io/pypi/pyversions/shandy-sqlfmt)\n![Runs on Linux | MacOS | Windows](https://img.shields.io/badge/runs%20on-Linux%20%7C%20MacOS%20%7C%20Windows-blue)\n\n\nsqlfmt formats your dbt SQL files so you don\'t have to. It is similar in nature to black, gofmt, \nand rustfmt (but for SQL). When you use sqlfmt:\n\n1. You never have to mention (or argue about) code style in code reviews again\n1. You make it easier to collaborate and solicit contributions from new people\n1. You will be able to read your team\'s code as if you wrote it\n1. You can forget about formatting your code, and spend your time on business logic instead\n\nsqlfmt is not configurable, except for line length. It enforces a single style. sqlfmt maintains comments and some extra newlines, but largely ignores all indentation and line breaks in the input file.\n\nsqlfmt is not a linter. It does not parse your code into an AST; it just lexes it and tracks a small subset of tokens that impact formatting. This lets us "do one thing and do it well:" sqlfmt is very fast, and easier to maintain and extend than linters that need a full SQL grammar.\n\nsqlfmt is designed to work with templated SQL files that contain jinja tags and blocks. It formats the code that users look at, and therefore doesn\'t need to know anything about what happens after the templates are rendered.\n\nFor now, sqlfmt only works on `select` statements (which is all you need if you use sqlfmt with a dbt project). In the future, it will be extended to DDL statements, as well.\n\n## Installation\n\n### Try it first\nWant to test out sqlfmt on a query before you install it? Go to [sqlfmt.com](https://sqlfmt.com) to use the interactive, web-based version.\n\n### Prerequisites\nYou will need Python 3.7-3.10 installed. You should use pipx or install into a virtual environment (maybe as a dev-dependency in your project). If you do not know how to install python and use pipx and/or virtual environments, go read about that first.\n\n### Install Using pipx (recommended)\n\n```\npipx install shandy-sqlfmt\n```\n\nTo install with the jinjafmt extra (which will also install the Python code formatter, *black*):\n\n```\npipx install shandy-sqlfmt[jinjafmt]\n```\n\n### Other Installation Options\nYou should use a virtual environment to isolate sqlfmt\'s dependencies from others on your system. We recommend poetry (`poetry add -D shandy-sqlfmt[jinjafmt]` or `poetry add -D shandy-sqlfmt`), or pipenv (`pipenv install -d shandy-sqlfmt[jinjafmt]`, etc.), but a simple `pip install shandy-sqlfmt` will also work.\n\n## Getting Started\n\n### Other prerequisites\n**sqlfmt is an alpha product** and will not always produce the formatted output you might want. It might even break your SQL syntax. It is **highly recommended** to only run sqlfmt on files in a version control system (like git), so that it is easy for you to revert any changes made by sqlfmt. On your first run, be sure to make a commit before running sqlfmt.\n\n### Using sqlfmt\nsqlfmt is a command-line tool. It works on any posix terminal and on Windows Powershell. If you have used `black`, the sqlfmt commands will look familiar. \n\n> Note: The `$` in the code snippets below indicate that these are commands that can be typed into your terminal. The `$` is the prompt symbol in bash; it is equivalent to `>` on Windows or `%` on zsh. Do not include the `$` in the command you type into your terminal\n\nTo list commands and options:\n\n```bash\n$ sqlfmt --help\n```\n\nIf you want to format all `.sql` and `.sql.jinja` files in your current working directory (and all nested directories), simply type:\n```bash\n$ sqlfmt .\n```\nYou can also supply a path to a one or more files or directories as arguments:\n```bash\n$ sqlfmt /path/to/my/dir /path/to/a/file.sql\n```\nIf you don\'t want to format the files you have on disk, you can run sqlfmt with the `--check` option. sqlfmt will exit with code 1 if the files on disk are not properly formatted:\n```bash\n$ sqlfmt --check .\n$ sqlfmt --check path/to/my/dir\n```\nIf you want to print a diff of changes that sqlfmt would make to format a file (but not update the file on disk), you can use the `--diff` option. `--diff` also exits with 1 on changes:\n```bash\n$ sqlfmt --diff .\n```\n\n### Disabling sqlfmt\n\nIf you would like sqlfmt to ignore a file, or part of a file, you can add `-- fmt: off` and `-- fmt: on` comments to your code (or `# fmt: off` on MySQL or BigQuery). sqlfmt will not change any code between those comments; a single `-- fmt: off` at the top of a file will keep the entire file intact.\n\n### The jinjafmt extra\n\nsqlfmt loves properly-formatted jinja, too.\n\nsqlfmt will safely attempt to import the Python code formatter, *black*. If it is successful (either because sqlfmt was installed with the **jinjafmt** extra or because black was installed separately in the same environment), it will use *black* to format the contents of jinja tags. If you do not want sqlfmt to use *black* to format your jinja, then specify the `--no-jinjafmt` flag when running sqlfmt.\n\nInstalling sqlfmt with the jinjafmt extra will also install *black*. You can do this with `pipx install sqlfmt[jinjafmt]` If you want to pin a specific *black* version, you should specify that separately, as a direct dependency of your project (in your Pipfile, pyproject.toml, etc.).\n\nIf sqlfmt was installed without the jinjafmt extra, and *black* is not otherwise installed, then sqlfmt will not attempt to format the contents of jinja tags, except for enforcing a single space inside each curly.\n\n### Configuring sqlfmt using pyproject.toml\n\nAny command-line option for sqlfmt can also be set in a `pyproject.toml` file, under a `[tool.sqlfmt]` section header. Options passed at the command line will override the settings in the config file.\n\nsqlfmt will search for the `pyproject.toml` file using the `files` passed to it as arguments. It starts in the lowest (most specific) common parent directory to all the `files` and recurses up to the root directory. It will load settings from the first `pyproject.toml` file it finds in this search.\n\nExample of a `pyproject.toml` file to override the default behaviors (run `sqlfmt --help` for more options):\n\n```toml\n[tool.sqlfmt]\nline_length = 100\ncheck = true\n```\n\n### Using sqlfmt with different SQL dialects\n\nsqlfmt\'s rules are simple, which means it does not have to parse every single token in your query. This allows nearly all SQL dialects to be formatted using sqlfmt\'s default "polyglot" dialect.\n\n#### ClickHouse\n\nThe exception to this is ClickHouse, which is case-sensitive where other dialects are not. By default, sqlfmt will lowercase all SQL keywords, database identifiers, aliases, etc. (basically anything that isn\'t quoted). This is bad for ClickHouse. To prevent the lowercasing of function names, database identifiers, and aliases, use the `--dialect clickhouse` option when running sqlfmt. For example,\n\n```bash\n$ sqlfmt . --dialect clickhouse\n```\n\nThis can also be configured using the `pyproject.toml` file:\n\n```toml\n[tool.sqlfmt]\ndialect = "clickhouse"\n```\n\nNote that with this option, sqlfmt will not lowercase **most** non-reserved keywords, even common ones like `sum` or `count`. See (and please join) [this discussion](https://github.com/tconbeer/sqlfmt/discussions/229) for more on this topic.\n\n### Using sqlfmt with dbt\n\nsqlfmt was built for dbt, so only minimal configuration is required. We recommend excluding your `target` and `dbt_packages` directories from formatting. You can do this with the command-line `--exclude` option, or by setting `exclude` in your `pyproject.toml` file:\n\n```toml\n[tool.sqlfmt]\nexclude=["target/**/*", "dbt_packages/**/*"]\n```\n\n### Using sqlfmt with pre-commit\nYou can configure [pre-commit](https://pre-commit.com/) to run sqlfmt on your repository before you commit changes.\n\nAdd the following config to your `.pre-commit-config.yaml` file:\n\n```yml\nrepos:\n  - repo: https://github.com/tconbeer/sqlfmt\n    rev: v0.11.0\n    hooks:\n      - id: sqlfmt\n        language_version: python\n```\n\nYou should replace `rev` with the latest available release, but we do suggest pinning to a specific rev, to avoid unexpected formatting changes.\n\n### Using sqlfmt with SQLFluff\n\nYou can (and should!) use SQLFluff to lint your SQL queries after they are formatted by sqlfmt. However, the two tools do not see eye-to-eye on formatting (by default), so to avoid lint errors, add the following to your `.sqlfluff` config file:\n\n```ini\n[sqlfluff]\nexclude_rules = L003, L018, L036\n\n[sqlfluff:rules]\nmax_line_length = 88  # or whatever you set in sqlfmt\ncapitalisation_policy = lower\nextended_capitalisation_policy = lower\n\n[sqlfluff:indentation]\nindented_joins = False\nindented_using_on = True\ntemplate_blocks_indent = False\n\n[sqlfluff:rules:L052]\nmultiline_newline = True\n```\n\n### Using sqlfmt with VS Code\n\nYou can use the [Run on Save](https://marketplace.visualstudio.com/items?itemName=emeraldwalk.RunOnSave) extension with sqlfmt to automatically format files when they are saved. After installing the extension, on the extension\'s page, click the gear icon to access the extension settings. Choose if you would like to create either a User or Workspace setting, and select the appropriate tab. Then select "Edit in settings.json", and add the following:\n\n```JSON\n{\n    "emeraldwalk.runonsave": {\n        "commands": [\n            {\n                "match": ".*\\\\.sql(\\\\.jinja)?",\n                "isAsync": true,\n                "cmd": "sqlfmt ${file}"\n            }\n        ]\n    }\n}\n```\n\n(Note that you should either use a `pyproject.toml` file or add other options to the `cmd` key in the settings above if you would like to change the default behavior of sqlfmt)\n\n## The sqlfmt style\nThe only thing you can configure with sqlfmt is the desired line length of the formatted file. You can do this with the `--line-length` or `-l` options. The default is 88.\n\nGiven the desired line length, sqlfmt has three objectives:\n1. Break and indent lines to make the syntactical structure of the code apparent.\n2. Combine lines to use the least possible vertical space, without violating the line-length constraint or the structure in #1.\n3. Standardize capitalization (to lowercase) and in-line whitespace.\n\nsqlfmt borrows elements from well-accepted styles from other programming languages. It places opening brackets on the same line as preceding function names (like *black* for python and *1TBS* for C). It indents closing brackets to the same depth as the opening bracket (this is extended to statements that must be closed, like `case` and `end`).\n\nThe sqlfmt style is as simple as possible, with little-to-no special-casing of formatting concerns. While at first blush, this may not create a format that is as "nice" or "expressive" as hand-crafted indentation, over time, as you grow accustomed to the style, formatting becomes transparent and the consistency will allow you to jump between files, projects, and even companies much faster.\n\n### Why lowercase?\nThere are several reasons that sqlfmt insists on lowercase SQL keywords:\n1. We believe that SQL is code (this is a surprisingly controversial statement!). Shouting-case keywords perpetuate the myth that SQL isn\'t "real code", or isn\'t "modern" and somehow is trapped in the era of low-level imperative languages: BASIC, COBOL, and FORTRAN. The reality is that SQL is an incredibly powerful, declarative, and modern language. It should look like one.\n1. Syntax highlighting for SQL makes shouting-case keywords redundant; the syntax highlighter in any text editor is going to be more consistent than any manual shout-casing. If you have a SQL query as a string inside of a block of code in another language, you may want to capitalize your keywords; sqlfmt only operates on dedicated SQL (and templated sql) files, so this is not relevant. However, even without syntax highlighting, the hierarchical and consistent indentation provided by sqlfmt provides sufficient visual structure without shout-casing keywords.\n1. Even among people who like shout-cased keywords, there are disagreements between what gets shout-cased. SELECT, sure, but SUM? AS? OVER? AND? All-lowercase keywords eliminates this potential source of irregularity and disagreement.\n1. Research shows that generally, lowercase words are more readable.\n\n### Why trailing commas?\n1. Using trailing commas follows the convention of every other written language and programming language.\n1. Leading commas require placing the first field name on the same line as `select`, which can obscure that field (especially with `select distinct top 25 ...`).\n1. SQL query compilation is extremely fast; the "cost" of "last field" errors is very low. Some dialects (e.g., BigQuery, DuckDB) even allow a trailing comma in the final field of a select statement.\n1. Trailing commas generalize better within `select` statements (e.g. `group by` and `partition by` clauses) and in other kinds of SQL statements (e.g. `insert` statements).\n\n### Examples\n\nsqlfmt will put very short queries on a single line:\n\n```sql\nSELECT a,\nb,\n   c\nFROM my_table\n```\nbecomes\n```sql\nselect a, b, c from my_table\n```\n\nIf a query doesn\'t fit on a single line, sqlfmt will format the query to make its hierarchy apparent. The main keywords in a `select` statement are the top nodes in hierarchy. Individual fields are indented a single level; unless all fields fit on the same line as `select`, they must all be individually split onto their own lines. This is properly formatted code:\n```sql\nwith t as (select * from my_schema."my_QUOTED_ table!")\nselect\n    a_long_field_name,\n    another_long_field_name,\n    (one_field + another_field) as c,\n    a_final_field\nfrom t\nwhere one_field < another_field\n```\n\nNote that the main keywords, `with`, `select`, `from`, and `where`, are indented to the same depth. If their arguments fit on a single line (as in `with`, `from`, and `where`), they stay on that line, with the keyword. However, unless all arguments for a keyword fit on one line, they are all wrapped to their own line, and indented:\n\n```sql\nwith\n    a_long_cte_name as (\n        select my_field, sum(another_field) from my_schema."my_QUOTED_ table!"\n    )\nselect\n    a_long_field_name,\n    another_long_field_name,\n    (one_field + another_field) as c,\n    a_final_field\nfrom a_long_cte_name\nwhere\n    one_field < another_field\n    and two_field > another_field\n    and three_field = another_field\n```\n\nAny expressions wrapped in parentheses are similarly one-lined if possible, and split if they are too long.\n\nThis hierarchical indentation scales to arbitrarily complex and nested expressions. Another example of properly formatted code (at line length of 88):\n\n```sql\nselect\n    a,\n    sum(a) over () as b,\n    row_number() over () as c,\n    count(case when a is null then 1 end) over (\n        partition by user_id, date_trunc(\'year\', performed_at)\n    ) as d,\n    first_value(\n        coalesce(one_field, another_field, yet_another_field) ignore nulls\n    ) over (\n        partition by user_id\n        order by performed_at desc\n        rows between unbounded preceding and unbounded following\n    ) as e\nfrom my_table\n```\nWant more examples? See the `tests/data` directory, or go to https://sqlfmt.com to see how sqlfmt will format your queries.\n\n## Contributing\n\n[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)\n[![Checked with mypy](http://www.mypy-lang.org/static/mypy_badge.svg)](http://mypy-lang.org/)\n[![Maintainability](https://api.codeclimate.com/v1/badges/8928f6662a67b8eaf092/maintainability)](https://codeclimate.com/github/tconbeer/sqlfmt/maintainability)\n[![Test Coverage](https://api.codeclimate.com/v1/badges/8928f6662a67b8eaf092/test_coverage)](https://codeclimate.com/github/tconbeer/sqlfmt/test_coverage)\n\n### Providing Feedback\n\nWe\'d love to hear from you! [Open an Issue](https://github.com/tconbeer/sqlfmt/issues/new/choose) to request new features, report bad formatting, or say hello.\n\n### Setting up Your Dev Environment and Running Tests\n\n1. Install [Poetry](https://python-poetry.org/docs/#installation) if you don\'t have it already. You may also need or want pyenv, make, and gcc. A complete setup from a fresh install of Ubuntu can be found [here](https://github.com/tconbeer/linux_setup)\n1. Clone this repo into a directory (let\'s call it `sqlfmt`), then `cd sqlfmt`\n1. Use `poetry install -E jinjafmt` to install the project (editable) and its dependencies into a new virtual env. To run `sqlfmt_primer`, you will need to install it (and its dependencies) by specifying it as an extra: `poetry install -E jinjafmt -E sqlfmt_primer`\n1. Use `poetry shell` to spawn a subshell\n1. Type `make` to run all tests and linters, or run `pytest`, `black`, `flake8`, `isort`, and `mypy` individually.\n\nNote: If encountering a JSONDecodeError during `poetry install`, you will want to clear the poetry cache with `poetry cache clear pypi --all`, or upgrade to poetry >= 1.12 with `poetry self upgrade`\n\n### Updating primer repos to reflect formatting changes\n\n1. Make sure all changes are committed to sqlfmt\n1. Check out `main` in the repo and make sure you `pull` changes locally\n1. Check out the `unformatted` tag in the repo with `git checkout -b chore/apply-abc123 unformatted` where `abc123` is the hash of the most recent sqlfmt commit (from 1)\n1. Run sqlfmt against the working tree, then `git add .` and `git commit -m "chore: apply sqlfmt abc123"`\n1. We will have conflicts with main that we want to ignore, so merge main into this branch, ignoring anything on main: `git merge -s ours main`\n1. Push and open a PR; squash and merge. Grab the commit SHA\n1. Paste the commit SHA as a ref into `primer.py`\n1. Run `sqlfmt_primer -k` to clear the cache, then update the stats in `primer.py` to match the results',
    'author': 'Ted Conbeer',
    'author_email': 'ted@shandy.io',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://sqlfmt.com',
    'package_dir': package_dir,
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'extras_require': extras_require,
    'entry_points': entry_points,
    'python_requires': '>=3.7,<4.0',
}


setup(**setup_kwargs)
