"""Literate dataclasses: Improved documentation for dataclasses.

Modify the docstring of a Python dataclass to contain parameter docs.
Intended to use as a decorator, but could also be applied to a class as
a function.

To use this functionality, make sure the class docstring is of the following
format:

.. code: python

    from literate_dataclasses import dataclass, field

    @dataclass
    class YourClass:
        '''An example class

        Docs to appear before the arguments.

        Args:
            some placeholder line---will be removed.

        Docs to appear after the arguments
        '''

        attribute: field(..., doc = "docstring")
        ...

Documenting dataclasses in this way will yield consistent documentation across
python ``help``, documentation generated by sphinx, and will be readable in the
source code.
"""

__version__ = "0.0.6"

import dataclasses


def attributedocs(cls, *, doc_key: str = "Args"):
    """Modify the docstring of a literate dataclass.

    Args:
        cls: A class decorated with ``literate_dataclasses.dataclass``. All
            fields initialized with a ``doc=...`` keyword argument are added
            to the class docstring ``cls.__doc__`` at the specified position.
        doc_key: Optional key in the class doc string. The line immediately
            following this key will be replaced by an argument list.
    """
    docs = cls.__doc__.split("\n")
    new_doc = []
    while len(docs):
        line = docs.pop(0)
        if doc_key in line:
            new_doc.append(line)
            docs.pop(0)
            for field_ in dataclasses.fields(cls):
                if "doc" not in field_.metadata:
                    continue
                doc = field_.metadata["doc"]
                docstring = str(doc).replace("\n", "\n        ")
                new_doc.append(f"        {field_.name}: {docstring}")
        else:
            new_doc.append(line)
    cls.__doc__ = "\n".join(new_doc)
    return cls


def field(*, metadata: dict = None, doc: str = None, **kwargs) -> dataclasses.Field:
    """Add a ``dataclasses.field`` with additional attribute documentation.

    Refer to ``dataclasses.field`` in the standard library for full documentation
    of all possible keyword arguments. The ``metadata`` argument can still be used
    for compatibility with existing code, but should be defined by a dictionary.

    Args:
        metadata: Metadata argument, restricted to dictionary-like types when using
            literate dataclasses.
        doc: The docstring for the dataclass attribute.
    """
    if metadata is None:
        metadata = {}
    if not isinstance(metadata, dict):
        raise ValueError(
            "When using literate_dataclasses, pass docstrings directly "
            "using field(doc = ...) instead of assigning metadata explicitly. "
            "For customized additional metadata, the metadata argument needs to "
            "be assigned a dict."
        )
    kwargs["metadata"] = dict(doc=doc, **metadata)
    return dataclasses.field(**kwargs)


def dataclass(cls=None, /, **kwargs):
    """Wrapper around ``dataclasses.dataclass`` which additionally modifies __doc__."""

    def _wrap(cls):
        cls = dataclasses.dataclass(cls, **kwargs)
        attributedocs(cls)
        return cls

    return _wrap(cls)


def forkable(cls):
    """Adds a ``fork()`` function to a dataclass.

    The function will take optional keyword arguments corresponding to the arguments
    of the dataclass. The fork is a new instantion of the class, where all fields are
    set to the respective member functions, except for the ones which are overridden
    by passing them as arguments to ``fork()``.

    Note that the forked instance will not contain deepcopies of member attributes.

    Example:
        >>> @forkable
        >>> @dataclasses.dataclass
        ... class A():
        ...     foo: int = 42
        ...     bar: int = 44
        ...     baz: typing.List = dataclasses.field(default_factory = list)
        >>> print(A().__dict__, A().fork(bar = 100).__dict__)
        {'foo': 42, 'bar': 44} {'foo': 42, 'bar': 100}
        >>> a = A()
        >>> b = a.fork()
        >>> a.baz.append("hello")
        >>> b.baz.append("world")
        >>> print(b.baz)
        ['hello', 'world']

    """

    if not hasattr(cls, "__dataclass_fields__"):
        raise ValueError("Only dataclasses are forkable.")
    if hasattr(cls, "fork"):
        raise ValueError("Class already has a fork() function.")

    fields = {field_.name: field_ for field_ in dataclasses.fields(cls)}

    def fork(self, **kwargs):
        assert all(key in fields.keys() for key in kwargs)

        all_kwargs = {}
        for field_name, field_ in fields.items():
            if field_name in kwargs:
                assert isinstance(kwargs[field_name], field_.type)
                all_kwargs[field_name] = kwargs[field_name]
            else:
                all_kwargs[field_name] = getattr(self, field_name)
        return cls(**all_kwargs)

    setattr(cls, "fork", fork)
    return cls


# pylint: disable=C0103
def __getattr__(key):
    if hasattr(dataclasses, key):
        return getattr(dataclasses, key)
    raise AttributeError(key)
