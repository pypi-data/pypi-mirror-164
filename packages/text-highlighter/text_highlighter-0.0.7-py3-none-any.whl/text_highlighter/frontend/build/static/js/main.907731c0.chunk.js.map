{"version":3,"sources":["TextHighlighter.tsx","index.tsx"],"names":["MyComponent","state","tag","isFocused","render","annotations","props","args","colors","labels","text","selected_label","show_label_selector","theme","style","borderStyling","primaryColor","border","outline","initial","value","setState","onChange","e","target","map","label","key","maxWidth","lineHeight","content","updateState","getSpan","span","color","indexOf","mergeAnnotations","annotation1","isOverlapping","otherAnnotation","annotation2","start","end","newAnnotations","annotation3","push","callback","Streamlit","setComponentValue","_onFocus","_onBlur","StreamlitComponentBase","withStreamlitConnection","ReactDOM","TextHighlighter","document","getElementById"],"mappings":"+RAkBMA,E,4MACGC,MAAQ,CAAEC,IAAK,GAAIC,WAAW,G,EAE9BC,OAAS,WAGd,IAAMC,EAAc,EAAKC,MAAMC,KAAX,YACdC,EAAS,EAAKF,MAAMC,KAAX,OACTE,EAAS,EAAKH,MAAMC,KAAX,OACTG,EAAO,EAAKJ,MAAMC,KAAX,KACPI,EAAiB,EAAKL,MAAMC,KAAX,eACjBK,EAAsB,EAAKN,MAAMC,KAAX,oBAKpBM,EAAU,EAAKP,MAAfO,MACFC,EAA6B,GAInC,GAAID,EAAO,CAGT,IAAME,EAAa,oBAAgB,EAAKd,MAAME,UAAYU,EAAMG,aAAe,QAE/EF,EAAMG,OAASF,EACfD,EAAMI,QAAUH,EAQlB,OACE,kBAAC,IAAD,CAAOI,QAAS,CAAEC,MAAOf,EAAaH,IAAKS,KACxC,gBAAGV,EAAH,EAAGA,MAAOoB,EAAV,EAAUA,SAAV,OACC,8BACGT,GAAuB,4BACtBU,SAAU,SAAAC,GAAC,OAAIF,EAAS,CAAEnB,IAAKqB,EAAEC,OAAOJ,SACxCA,MAAOnB,EAAMC,KAEZO,EAAOgB,KAAI,SAACC,GAAD,OACV,4BAAQC,IAAKD,EAAON,MAAOM,GACxBA,OAIP,kBAAC,gBAAD,CACEZ,MAAO,CACLc,SAAU,IACVC,WAAY,KAEdC,QAASpB,EACTU,MAAOnB,EAAMmB,MACbE,SAAU,SAACF,GAAD,OAAgB,EAAKW,YAAYX,EAAOC,IAClDW,QAAS,SAAAC,GAAI,kCACRA,GADQ,IAEX/B,IAAKD,EAAMC,IACXgC,MAAO1B,EAAOC,EAAO0B,QAAQlC,EAAMC,gB,EAUzCkC,iBAAmB,SAAC/B,GAAuB,oBAGvBA,GAHuB,IAGjD,2BAAuC,CAAC,IAAD,EAA5BgC,EAA4B,QACjCC,GAAgB,EAChBC,EAAkB,KAFe,cAGXlC,GAHW,IAGrC,2BAAuC,CAAC,IAA7BmC,EAA4B,QACrC,IAAIH,EAAYI,QAAUD,EAAYC,OAASJ,EAAYK,MAAQF,EAAYE,OAC1EF,EAAYC,OAASJ,EAAYI,OAASD,EAAYE,KAAOL,EAAYI,OAAWD,EAAYC,OAASJ,EAAYK,KAAOF,EAAYE,KAAOL,EAAYK,KAAM,CACpKJ,GAAgB,EAChBC,EAAkBC,EAClB,QARiC,8BAWrC,GAAIF,EAAe,CACjB,IADiB,EACXK,EAAiB,GADN,cAEStC,GAFT,IAEjB,2BAAuC,CAAC,IAA7BuC,EAA4B,QACjCA,EAAYH,QAAUJ,EAAYI,OAASG,EAAYF,MAAQL,EAAYK,KAAOE,EAAYH,QAAUF,EAAgBE,OAASG,EAAYF,MAAQH,EAAgBG,KACvKC,EAAeE,KAAKD,IAJP,8BAQjB,OAAOD,IAtBsC,8BAyBjD,OAAOtC,G,EAGD0B,YAAc,SAACX,EAAY0B,GAEjCA,EAAS,CAAE1B,MADXA,EAAQ,EAAKgB,iBAAiBhB,KAE9B2B,IAAUC,kBAAkB5B,I,EAItB6B,SAAW,WACjB,EAAK5B,SAAS,CAAElB,WAAW,K,EAIrB+C,QAAU,WAChB,EAAK7B,SAAS,CAAElB,WAAW,K,yBA/GLgD,KAwHXC,cAAwBpD,GCtIvCqD,IAASjD,OACP,kBAACkD,EAAD,MACAC,SAASC,eAAe,W","file":"static/js/main.907731c0.chunk.js","sourcesContent":["import {\n  Streamlit,\n  StreamlitComponentBase,\n  withStreamlitConnection,\n} from \"streamlit-component-lib\"\nimport React, { ReactNode } from \"react\"\nimport { TextAnnotator } from 'react-text-annotate'\nimport { State } from 'react-powerplug'\n\ninterface BaseState {\n  isFocused: boolean,\n  tag: string,\n}\n\n/**\n * This is a React-based component template. The `render()` function is called\n * automatically when your component should be re-rendered.\n */\nclass MyComponent extends StreamlitComponentBase<BaseState> {\n  public state = { tag: '', isFocused: false }\n\n  public render = (): ReactNode => {\n    // Arguments that are passed to the plugin in Python are accessible\n    // via `this.props.args`. Here, we access the \"name\" arg.\n    const annotations = this.props.args[\"annotations\"]\n    const colors = this.props.args[\"colors\"]\n    const labels = this.props.args[\"labels\"]\n    const text = this.props.args[\"text\"]\n    const selected_label = this.props.args[\"selected_label\"]\n    const show_label_selector = this.props.args[\"show_label_selector\"]\n\n    // Streamlit sends us a theme object via props that we can use to ensure\n    // that our component has visuals that match the active theme in a\n    // streamlit app.\n    const { theme } = this.props\n    const style: React.CSSProperties = {}\n\n    // Maintain compatibility with older versions of Streamlit that don't send\n    // a theme object.\n    if (theme) {\n      // Use the theme object to style our button border. Alternatively, the\n      // theme style is defined in CSS vars.\n      const borderStyling = `1px solid ${this.state.isFocused ? theme.primaryColor : \"gray\"\n        }`\n      style.border = borderStyling\n      style.outline = borderStyling\n    }\n\n    // Show a button and some text.\n    // When the button is clicked, we'll increment our \"numClicks\" state\n    // variable, and send its new value back to Streamlit, where it'll\n    // be available to the Python program.\n    // initial={{ value: [{ start: 18, end: 28, tag: 'PERSON' }], tag: 'PERSON' }}\n    return (\n      <State initial={{ value: annotations, tag: selected_label }}>\n        {({ state, setState }) => (\n          <span>\n            {show_label_selector && <select\n              onChange={e => setState({ tag: e.target.value })}\n              value={state.tag}\n            >\n              {labels.map((label: any) => (\n                <option key={label} value={label}>\n                  {label}\n                </option>\n              ))}\n            </select>}\n            <TextAnnotator\n              style={{\n                maxWidth: 500,\n                lineHeight: 1.5\n              }}\n              content={text}\n              value={state.value}\n              onChange={(value: any) => this.updateState(value, setState)}\n              getSpan={span => ({\n                ...span,\n                tag: state.tag,\n                color: colors[labels.indexOf(state.tag)],\n              })}\n            />\n          </span>\n        )}\n      </State>\n\n    )\n  }\n\n  private mergeAnnotations = (annotations: any[]) => {\n    // Remove all annotations which are a subannotation of another annotation;\n    // which means that annotation2.start >= annotation1.start and annotation2.end <= annotation1.end\n    for (const annotation1 of annotations) {\n      var isOverlapping = false;\n      let otherAnnotation = null;\n      for (const annotation2 of annotations) {\n        if (annotation1.start === annotation2.start && annotation1.end === annotation2.end) continue;\n        if ((annotation2.start <= annotation1.start && annotation2.end >= annotation1.start) || (annotation2.start <= annotation1.end && annotation2.end >= annotation1.end)) {\n          isOverlapping = true;\n          otherAnnotation = annotation2;\n          break;\n        }\n      }\n      if (isOverlapping) {\n        const newAnnotations = [];\n        for (const annotation3 of annotations) {\n          if (annotation3.start !== annotation1.start && annotation3.end !== annotation1.end && annotation3.start !== otherAnnotation.start && annotation3.end !== otherAnnotation.end) {\n            newAnnotations.push(annotation3);\n          }\n        }\n        // Deselect both annotation1 and otherannotation\n        return newAnnotations;\n      }\n    }\n    return annotations;\n  }\n\n  private updateState = (value: any, callback: any): void => {\n    value = this.mergeAnnotations(value);\n    callback({ value });\n    Streamlit.setComponentValue(value);\n  }\n\n  /** Focus handler for our \"Click Me!\" button. */\n  private _onFocus = (): void => {\n    this.setState({ isFocused: true })\n  }\n\n  /** Blur handler for our \"Click Me!\" button. */\n  private _onBlur = (): void => {\n    this.setState({ isFocused: false })\n  }\n}\n\n// \"withStreamlitConnection\" is a wrapper function. It bootstraps the\n// connection between your component and the Streamlit app, and handles\n// passing arguments from Python -> Component.\n//\n// You don't need to edit withStreamlitConnection (but you're welcome to!).\nexport default withStreamlitConnection(MyComponent)\n","import React from \"react\"\nimport ReactDOM from \"react-dom\"\nimport TextHighlighter from \"./TextHighlighter\"\n\nReactDOM.render(\n  <TextHighlighter />,\n  document.getElementById(\"root\")\n)\n"],"sourceRoot":""}