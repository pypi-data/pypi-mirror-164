"use strict";(self.webpackChunkreact_frontend=self.webpackChunkreact_frontend||[]).push([[8190],{73855:(e,t,n)=>{n(56651),n(92412),n(37792)},37792:(e,t,n)=>{n(25734),n(95701),n(49060),n(99877);var s=n(98314),r=n(26213),i=n(32652);(0,s.k)({_template:r.d`
    <style include="paper-item-shared-styles"></style>
    <style>
      :host {
        @apply --layout-horizontal;
        @apply --layout-center;
        @apply --paper-font-subhead;

        @apply --paper-item;
        @apply --paper-icon-item;
      }

      .content-icon {
        @apply --layout-horizontal;
        @apply --layout-center;

        width: var(--paper-item-icon-width, 56px);
        @apply --paper-item-icon;
      }
    </style>

    <div id="contentIcon" class="content-icon">
      <slot name="item-icon"></slot>
    </div>
    <slot></slot>
`,is:"paper-icon-item",behaviors:[i.U]})},32652:(e,t,n)=>{n.d(t,{U:()=>i});n(25734);var s=n(48877),r=n(55643);const i=[s.P,r.a,{hostAttributes:{role:"option",tabindex:"0"}}]},99877:(e,t,n)=>{n(95701),n(10898),n(41928),n(49060);const s=document.createElement("template");s.setAttribute("style","display: none;"),s.innerHTML="<dom-module id=\"paper-item-shared-styles\">\n  <template>\n    <style>\n      :host, .paper-item {\n        display: block;\n        position: relative;\n        min-height: var(--paper-item-min-height, 48px);\n        padding: 0px 16px;\n      }\n\n      .paper-item {\n        @apply --paper-font-subhead;\n        border:none;\n        outline: none;\n        background: white;\n        width: 100%;\n        text-align: left;\n      }\n\n      :host([hidden]), .paper-item[hidden] {\n        display: none !important;\n      }\n\n      :host(.iron-selected), .paper-item.iron-selected {\n        font-weight: var(--paper-item-selected-weight, bold);\n\n        @apply --paper-item-selected;\n      }\n\n      :host([disabled]), .paper-item[disabled] {\n        color: var(--paper-item-disabled-color, var(--disabled-text-color));\n\n        @apply --paper-item-disabled;\n      }\n\n      :host(:focus), .paper-item:focus {\n        position: relative;\n        outline: 0;\n\n        @apply --paper-item-focused;\n      }\n\n      :host(:focus):before, .paper-item:focus:before {\n        @apply --layout-fit;\n\n        background: currentColor;\n        content: '';\n        opacity: var(--dark-divider-opacity);\n        pointer-events: none;\n\n        @apply --paper-item-focused-before;\n      }\n    </style>\n  </template>\n</dom-module>",document.head.appendChild(s.content)},56651:(e,t,n)=>{n(25734),n(95701),n(99877);var s=n(98314),r=n(26213),i=n(32652);(0,s.k)({_template:r.d`
    <style include="paper-item-shared-styles">
      :host {
        @apply --layout-horizontal;
        @apply --layout-center;
        @apply --paper-font-subhead;

        @apply --paper-item;
      }
    </style>
    <slot></slot>
`,is:"paper-item",behaviors:[i.U]})},88262:(e,t,n)=>{function s(e){return Array.isArray?Array.isArray(e):"[object Array]"===Object.prototype.toString.call(e)}n.d(t,{Z:()=>z});function r(e){return"string"==typeof e}function i(e){return"number"==typeof e}function c(e){return null!=e}function a(e){return!e.trim().length}const o=Object.prototype.hasOwnProperty;class h{constructor(e){this._keys={},this._keyNames=[];let t=0;e.forEach((e=>{let n,s=1;if(r(e))n=e;else{if(!o.call(e,"name"))throw new Error(`Missing ${"name"} property in key`);if(n=e.name,o.call(e,"weight")&&(s=e.weight,s<=0))throw new Error((e=>`Property 'weight' in key '${e}' must be a positive integer`)(n))}this._keyNames.push(n),this._keys[n]={weight:s},t+=s})),this._keyNames.forEach((e=>{this._keys[e].weight/=t}))}get(e,t){return this._keys[e]&&this._keys[e][t]}keys(){return this._keyNames}toJSON(){return JSON.stringify(this._keys)}}var l={isCaseSensitive:!1,includeScore:!1,keys:[],shouldSort:!0,sortFn:(e,t)=>e.score===t.score?e.idx<t.idx?-1:1:e.score<t.score?-1:1,includeMatches:!1,findAllMatches:!1,minMatchCharLength:1,location:0,threshold:.6,distance:100,...{useExtendedSearch:!1,getFn:function(e,t){let n=[],a=!1;const o=(e,t)=>{if(t){const h=t.indexOf(".");let l=t,u=null;-1!==h&&(l=t.slice(0,h),u=t.slice(h+1));const d=e[l];if(!c(d))return;if(u||!r(d)&&!i(d))if(s(d)){a=!0;for(let e=0,t=d.length;e<t;e+=1)o(d[e],u)}else u&&o(d,u);else n.push(function(e){return null==e?"":function(e){if("string"==typeof e)return e;let t=e+"";return"0"==t&&1/e==-1/0?"-0":t}(e)}(d))}else n.push(e)};return o(e,t),a?n:n[0]}}};const u=/[^ ]+/g;class d{constructor({getFn:e=l.getFn}={}){this.norm=function(e=3){const t=new Map;return{get(n){const s=n.match(u).length;if(t.has(s))return t.get(s);const r=parseFloat((1/Math.sqrt(s)).toFixed(e));return t.set(s,r),r},clear(){t.clear()}}}(3),this.getFn=e,this.isCreated=!1,this.setRecords()}setCollection(e=[]){this.docs=e}setRecords(e=[]){this.records=e}setKeys(e=[]){this.keys=e}create(){!this.isCreated&&this.docs.length&&(this.isCreated=!0,r(this.docs[0])?this.docs.forEach(((e,t)=>{this._addString(e,t)})):this.docs.forEach(((e,t)=>{this._addObject(e,t)})),this.norm.clear())}add(e){const t=this.size();r(e)?this._addString(e,t):this._addObject(e,t)}removeAt(e){this.records.splice(e,1);for(let t=e,n=this.size();t<n;t+=1)this.records[t].i-=1}size(){return this.records.length}_addString(e,t){if(!c(e)||a(e))return;let n={v:e,i:t,n:this.norm.get(e)};this.records.push(n)}_addObject(e,t){let n={i:t,$:{}};this.keys.forEach(((t,i)=>{let o=this.getFn(e,t);if(c(o))if(s(o)){let e=[];const t=[{nestedArrIndex:-1,value:o}];for(;t.length;){const{nestedArrIndex:n,value:i}=t.pop();if(c(i))if(r(i)&&!a(i)){let t={v:i,i:n,n:this.norm.get(i)};e.push(t)}else s(i)&&i.forEach(((e,n)=>{t.push({nestedArrIndex:n,value:e})}))}n.$[i]=e}else if(!a(o)){let e={v:o,n:this.norm.get(o)};n.$[i]=e}})),this.records.push(n)}toJSON(){return{keys:this.keys,records:this.records}}}function p(e,t,{getFn:n=l.getFn}={}){let s=new d({getFn:n});return s.setKeys(e),s.setCollection(t),s.create(),s}function f(e,t){const n=e.matches;t.matches=[],c(n)&&n.forEach((e=>{if(!c(e.indices)||!e.indices.length)return;const{indices:n,value:s}=e;let r={indices:n,value:s};e.key&&(r.key=e.key),e.idx>-1&&(r.refIndex=e.idx),t.matches.push(r)}))}function g(e,t){t.score=e.score}function m(e,{errors:t=0,currentLocation:n=0,expectedLocation:s=0,distance:r=l.distance}={}){const i=t/e.length,c=Math.abs(s-n);return r?i+c/r:c?1:i}const y=32;function M(e,t,n,{location:s=l.location,distance:r=l.distance,threshold:i=l.threshold,findAllMatches:c=l.findAllMatches,minMatchCharLength:a=l.minMatchCharLength,includeMatches:o=l.includeMatches}={}){if(t.length>y)throw new Error(`Pattern length exceeds max of ${y}.`);const h=t.length,u=e.length,d=Math.max(0,Math.min(s,u));let p=i,f=d;const g=[];if(o)for(let e=0;e<u;e+=1)g[e]=0;let M;for(;(M=e.indexOf(t,f))>-1;){let e=m(t,{currentLocation:M,expectedLocation:d,distance:r});if(p=Math.min(e,p),f=M+h,o){let e=0;for(;e<h;)g[M+e]=1,e+=1}}f=-1;let x=[],v=1,k=h+u;const b=1<<(h<=31?h-1:30);for(let s=0;s<h;s+=1){let i=0,a=k;for(;i<a;){m(t,{errors:s,currentLocation:d+a,expectedLocation:d,distance:r})<=p?i=a:k=a,a=Math.floor((k-i)/2+i)}k=a;let l=Math.max(1,d-a+1),y=c?u:Math.min(d+a,u)+h,M=Array(y+2);M[y+1]=(1<<s)-1;for(let i=y;i>=l;i-=1){let c=i-1,a=n[e.charAt(c)];if(a&&o&&(g[c]=1),M[i]=(M[i+1]<<1|1)&a,0!==s&&(M[i]|=(x[i+1]|x[i])<<1|1|x[i+1]),M[i]&b&&(v=m(t,{errors:s,currentLocation:c,expectedLocation:d,distance:r}),v<=p)){if(p=v,f=c,f<=d)break;l=Math.max(1,2*d-f)}}if(m(t,{errors:s+1,currentLocation:d,expectedLocation:d,distance:r})>p)break;x=M}let E={isMatch:f>=0,score:Math.max(.001,v)};return o&&(E.indices=function(e=[],t=l.minMatchCharLength){let n=[],s=-1,r=-1,i=0;for(let c=e.length;i<c;i+=1){let c=e[i];c&&-1===s?s=i:c||-1===s||(r=i-1,r-s+1>=t&&n.push([s,r]),s=-1)}return e[i-1]&&i-s>=t&&n.push([s,i-1]),n}(g,a)),E}function x(e){let t={},n=e.length;for(let s=0;s<n;s+=1)t[e.charAt(s)]=0;for(let s=0;s<n;s+=1)t[e.charAt(s)]|=1<<n-s-1;return t}class v{constructor(e,{location:t=l.location,threshold:n=l.threshold,distance:s=l.distance,includeMatches:r=l.includeMatches,findAllMatches:i=l.findAllMatches,minMatchCharLength:c=l.minMatchCharLength,isCaseSensitive:a=l.isCaseSensitive}={}){this.options={location:t,threshold:n,distance:s,includeMatches:r,findAllMatches:i,minMatchCharLength:c,isCaseSensitive:a},this.pattern=a?e:e.toLowerCase(),this.chunks=[];let o=0;for(;o<this.pattern.length;){let e=this.pattern.substring(o,o+y);this.chunks.push({pattern:e,alphabet:x(e)}),o+=y}}searchIn(e){const{isCaseSensitive:t,includeMatches:n}=this.options;if(t||(e=e.toLowerCase()),this.pattern===e){let t={isMatch:!0,score:0};return n&&(t.indices=[[0,e.length-1]]),t}const{location:s,distance:r,threshold:i,findAllMatches:c,minMatchCharLength:a}=this.options;let o=[],h=0,l=!1;this.chunks.forEach((({pattern:t,alphabet:u},d)=>{const{isMatch:p,score:f,indices:g}=M(e,t,u,{location:s+y*d,distance:r,threshold:i,findAllMatches:c,minMatchCharLength:a,includeMatches:n});p&&(l=!0),h+=f,p&&g&&(o=[...o,...g])}));let u={isMatch:l,score:l?h/this.chunks.length:1};return l&&n&&(u.indices=o),u}}class k{constructor(e){this.pattern=e}static isMultiMatch(e){return b(e,this.multiRegex)}static isSingleMatch(e){return b(e,this.singleRegex)}search(){}}function b(e,t){const n=e.match(t);return n?n[1]:null}class E extends k{constructor(e){super(e)}static get type(){return"exact"}static get multiRegex(){return/^'"(.*)"$/}static get singleRegex(){return/^'(.*)$/}search(e){let t,n=0;const s=[],r=this.pattern.length;for(;(t=e.indexOf(this.pattern,n))>-1;)n=t+r,s.push([t,n-1]);const i=!!s.length;return{isMatch:i,score:i?1:0,indices:s}}}class S extends k{constructor(e,{location:t=l.location,threshold:n=l.threshold,distance:s=l.distance,includeMatches:r=l.includeMatches,findAllMatches:i=l.findAllMatches,minMatchCharLength:c=l.minMatchCharLength,isCaseSensitive:a=l.isCaseSensitive}={}){super(e),this._bitapSearch=new v(e,{location:t,threshold:n,distance:s,includeMatches:r,findAllMatches:i,minMatchCharLength:c,isCaseSensitive:a})}static get type(){return"fuzzy"}static get multiRegex(){return/^"(.*)"$/}static get singleRegex(){return/^(.*)$/}search(e){return this._bitapSearch.searchIn(e)}}const w=[E,class extends k{constructor(e){super(e)}static get type(){return"prefix-exact"}static get multiRegex(){return/^\^"(.*)"$/}static get singleRegex(){return/^\^(.*)$/}search(e){const t=e.startsWith(this.pattern);return{isMatch:t,score:t?0:1,indices:[0,this.pattern.length-1]}}},class extends k{constructor(e){super(e)}static get type(){return"inverse-prefix-exact"}static get multiRegex(){return/^!\^"(.*)"$/}static get singleRegex(){return/^!\^(.*)$/}search(e){const t=!e.startsWith(this.pattern);return{isMatch:t,score:t?0:1,indices:[0,e.length-1]}}},class extends k{constructor(e){super(e)}static get type(){return"inverse-suffix-exact"}static get multiRegex(){return/^!"(.*)"\$$/}static get singleRegex(){return/^!(.*)\$$/}search(e){const t=!e.endsWith(this.pattern);return{isMatch:t,score:t?0:1,indices:[0,e.length-1]}}},class extends k{constructor(e){super(e)}static get type(){return"suffix-exact"}static get multiRegex(){return/^"(.*)"\$$/}static get singleRegex(){return/^(.*)\$$/}search(e){const t=e.endsWith(this.pattern);return{isMatch:t,score:t?0:1,indices:[e.length-this.pattern.length,e.length-1]}}},class extends k{constructor(e){super(e)}static get type(){return"inverse-exact"}static get multiRegex(){return/^!"(.*)"$/}static get singleRegex(){return/^!(.*)$/}search(e){const t=-1===e.indexOf(this.pattern);return{isMatch:t,score:t?0:1,indices:[0,e.length-1]}}},S],C=w.length,L=/ +(?=([^\"]*\"[^\"]*\")*[^\"]*$)/;const _=new Set([S.type,E.type]);class A{constructor(e,{isCaseSensitive:t=l.isCaseSensitive,includeMatches:n=l.includeMatches,minMatchCharLength:s=l.minMatchCharLength,findAllMatches:r=l.findAllMatches,location:i=l.location,threshold:c=l.threshold,distance:a=l.distance}={}){this.query=null,this.options={isCaseSensitive:t,includeMatches:n,minMatchCharLength:s,findAllMatches:r,location:i,threshold:c,distance:a},this.pattern=t?e:e.toLowerCase(),this.query=function(e,t={}){return e.split("|").map((e=>{let n=e.trim().split(L).filter((e=>e&&!!e.trim())),s=[];for(let e=0,r=n.length;e<r;e+=1){const r=n[e];let i=!1,c=-1;for(;!i&&++c<C;){const e=w[c];let n=e.isMultiMatch(r);n&&(s.push(new e(n,t)),i=!0)}if(!i)for(c=-1;++c<C;){const e=w[c];let n=e.isSingleMatch(r);if(n){s.push(new e(n,t));break}}}return s}))}(this.pattern,this.options)}static condition(e,t){return t.useExtendedSearch}searchIn(e){const t=this.query;if(!t)return{isMatch:!1,score:1};const{includeMatches:n,isCaseSensitive:s}=this.options;e=s?e:e.toLowerCase();let r=0,i=[],c=0;for(let s=0,a=t.length;s<a;s+=1){const a=t[s];i.length=0,r=0;for(let t=0,s=a.length;t<s;t+=1){const s=a[t],{isMatch:o,indices:h,score:l}=s.search(e);if(!o){c=0,r=0,i.length=0;break}if(r+=1,c+=l,n){const e=s.constructor.type;_.has(e)?i=[...i,...h]:i.push(h)}}if(r){let e={isMatch:!0,score:c/r};return n&&(e.indices=i),e}}return{isMatch:!1,score:1}}}const $=[];function O(e,t){for(let n=0,s=$.length;n<s;n+=1){let s=$[n];if(s.condition(e,t))return new s(e,t)}return new v(e,t)}const R="$and",I="$or",j=e=>!(!e[R]&&!e[I]),N=e=>({[R]:Object.keys(e).map((t=>({[t]:e[t]})))});function F(e,t,{auto:n=!0}={}){const i=e=>{let c=Object.keys(e);if(c.length>1&&!j(e))return i(N(e));let a=c[0];if((e=>!s(e)&&"object"==typeof e&&!j(e))(e)){const s=e[a];if(!r(s))throw new Error((e=>`Invalid value for key ${e}`)(a));const i={key:a,pattern:s};return n&&(i.searcher=O(s,t)),i}let o={children:[],operator:a};return c.forEach((t=>{const n=e[t];s(n)&&n.forEach((e=>{o.children.push(i(e))}))})),o};return j(e)||(e=N(e)),i(e)}class P{constructor(e,t={},n){this.options={...l,...t},this.options.useExtendedSearch,this._keyStore=new h(this.options.keys),this.setCollection(e,n)}setCollection(e,t){if(this._docs=e,t&&!(t instanceof d))throw new Error("Incorrect 'index' type");this._myIndex=t||p(this._keyStore.keys(),this._docs,{getFn:this.options.getFn})}add(e){c(e)&&(this._docs.push(e),this._myIndex.add(e))}removeAt(e){this._docs.splice(e,1),this._myIndex.removeAt(e)}getIndex(){return this._myIndex}search(e,{limit:t=-1}={}){const{includeMatches:n,includeScore:s,shouldSort:c,sortFn:a}=this.options;let o=r(e)?r(this._docs[0])?this._searchStringList(e):this._searchObjectList(e):this._searchLogical(e);return function(e,t){e.forEach((e=>{let n=1;e.matches.forEach((({key:e,norm:s,score:r})=>{const i=t.get(e,"weight");n*=Math.pow(0===r&&i?Number.EPSILON:r,(i||1)*s)})),e.score=n}))}(o,this._keyStore),c&&o.sort(a),i(t)&&t>-1&&(o=o.slice(0,t)),function(e,t,{includeMatches:n=l.includeMatches,includeScore:s=l.includeScore}={}){const r=[];n&&r.push(f);s&&r.push(g);return e.map((e=>{const{idx:n}=e,s={item:t[n],refIndex:n};return r.length&&r.forEach((t=>{t(e,s)})),s}))}(o,this._docs,{includeMatches:n,includeScore:s})}_searchStringList(e){const t=O(e,this.options),{records:n}=this._myIndex,s=[];return n.forEach((({v:e,i:n,n:r})=>{if(!c(e))return;const{isMatch:i,score:a,indices:o}=t.searchIn(e);i&&s.push({item:e,idx:n,matches:[{score:a,value:e,norm:r,indices:o}]})})),s}_searchLogical(e){const t=F(e,this.options),{keys:n,records:s}=this._myIndex,r={},i=[],a=(e,t,s)=>{if(!e.children){const{key:s,searcher:r}=e,i=t[n.indexOf(s)];return this._findMatches({key:s,value:i,searcher:r})}{const n=e.operator;let c=[];for(let r=0;r<e.children.length;r+=1){let i=e.children[r],o=a(i,t,s);if(o&&o.length){if(c.push({idx:s,item:t,matches:o}),n===I)break}else if(n===R){c.length=0;break}}c.length&&(r[s]||(r[s]={idx:s,item:t,matches:[]},i.push(r[s])),c.forEach((({matches:e})=>{r[s].matches.push(...e)})))}};return s.forEach((({$:e,i:n})=>{c(e)&&a(t,e,n)})),i}_searchObjectList(e){const t=O(e,this.options),{keys:n,records:s}=this._myIndex,r=[];return s.forEach((({$:e,i:s})=>{if(!c(e))return;let i=[];n.forEach(((n,s)=>{i.push(...this._findMatches({key:n,value:e[s],searcher:t}))})),i.length&&r.push({idx:s,item:e,matches:i})})),r}_findMatches({key:e,value:t,searcher:n}){if(!c(t))return[];let r=[];if(s(t))t.forEach((({v:t,i:s,n:i})=>{if(!c(t))return;const{isMatch:a,score:o,indices:h}=n.searchIn(t);a&&r.push({score:o,key:e,value:t,idx:s,norm:i,indices:h})}));else{const{v:s,n:i}=t,{isMatch:c,score:a,indices:o}=n.searchIn(s);c&&r.push({score:a,key:e,value:s,norm:i,indices:o})}return r}}P.version="6.0.0",P.createIndex=p,P.parseIndex=function(e,{getFn:t=l.getFn}={}){const{keys:n,records:s}=e;let r=new d({getFn:t});return r.setKeys(n),r.setRecords(s),r},P.config=l,P.parseQuery=F,function(...e){$.push(...e)}(A);const z=P},19302:(e,t,n)=>{n.d(t,{Ud:()=>u});const s=Symbol("Comlink.proxy"),r=Symbol("Comlink.endpoint"),i=Symbol("Comlink.releaseProxy"),c=Symbol("Comlink.thrown"),a=e=>"object"==typeof e&&null!==e||"function"==typeof e,o=new Map([["proxy",{canHandle:e=>a(e)&&e[s],serialize(e){const{port1:t,port2:n}=new MessageChannel;return h(e,t),[n,[n]]},deserialize:e=>(e.start(),u(e))}],["throw",{canHandle:e=>a(e)&&c in e,serialize({value:e}){let t;return t=e instanceof Error?{isError:!0,value:{message:e.message,name:e.name,stack:e.stack}}:{isError:!1,value:e},[t,[]]},deserialize(e){if(e.isError)throw Object.assign(new Error(e.value.message),e.value);throw e.value}}]]);function h(e,t=self){t.addEventListener("message",(function n(r){if(!r||!r.data)return;const{id:i,type:a,path:o}=Object.assign({path:[]},r.data),u=(r.data.argumentList||[]).map(y);let d;try{const t=o.slice(0,-1).reduce(((e,t)=>e[t]),e),n=o.reduce(((e,t)=>e[t]),e);switch(a){case"GET":d=n;break;case"SET":t[o.slice(-1)[0]]=y(r.data.value),d=!0;break;case"APPLY":d=n.apply(t,u);break;case"CONSTRUCT":d=function(e){return Object.assign(e,{[s]:!0})}(new n(...u));break;case"ENDPOINT":{const{port1:t,port2:n}=new MessageChannel;h(e,n),d=function(e,t){return g.set(e,t),e}(t,[t])}break;case"RELEASE":d=void 0;break;default:return}}catch(e){d={value:e,[c]:0}}Promise.resolve(d).catch((e=>({value:e,[c]:0}))).then((e=>{const[s,r]=m(e);t.postMessage(Object.assign(Object.assign({},s),{id:i}),r),"RELEASE"===a&&(t.removeEventListener("message",n),l(t))}))})),t.start&&t.start()}function l(e){(function(e){return"MessagePort"===e.constructor.name})(e)&&e.close()}function u(e,t){return p(e,[],t)}function d(e){if(e)throw new Error("Proxy has been released and is not useable")}function p(e,t=[],n=function(){}){let s=!1;const c=new Proxy(n,{get(n,r){if(d(s),r===i)return()=>M(e,{type:"RELEASE",path:t.map((e=>e.toString()))}).then((()=>{l(e),s=!0}));if("then"===r){if(0===t.length)return{then:()=>c};const n=M(e,{type:"GET",path:t.map((e=>e.toString()))}).then(y);return n.then.bind(n)}return p(e,[...t,r])},set(n,r,i){d(s);const[c,a]=m(i);return M(e,{type:"SET",path:[...t,r].map((e=>e.toString())),value:c},a).then(y)},apply(n,i,c){d(s);const a=t[t.length-1];if(a===r)return M(e,{type:"ENDPOINT"}).then(y);if("bind"===a)return p(e,t.slice(0,-1));const[o,h]=f(c);return M(e,{type:"APPLY",path:t.map((e=>e.toString())),argumentList:o},h).then(y)},construct(n,r){d(s);const[i,c]=f(r);return M(e,{type:"CONSTRUCT",path:t.map((e=>e.toString())),argumentList:i},c).then(y)}});return c}function f(e){const t=e.map(m);return[t.map((e=>e[0])),(n=t.map((e=>e[1])),Array.prototype.concat.apply([],n))];var n}const g=new WeakMap;function m(e){for(const[t,n]of o)if(n.canHandle(e)){const[s,r]=n.serialize(e);return[{type:"HANDLER",name:t,value:s},r]}return[{type:"RAW",value:e},g.get(e)||[]]}function y(e){switch(e.type){case"HANDLER":return o.get(e.name).deserialize(e.value);case"RAW":return e.value}}function M(e,t,n){return new Promise((s=>{const r=new Array(4).fill(0).map((()=>Math.floor(Math.random()*Number.MAX_SAFE_INTEGER).toString(16))).join("-");e.addEventListener("message",(function t(n){n.data&&n.data.id&&n.data.id===r&&(e.removeEventListener("message",t),s(n.data))})),e.start&&e.start(),e.postMessage(Object.assign({id:r},t),n)}))}}}]);