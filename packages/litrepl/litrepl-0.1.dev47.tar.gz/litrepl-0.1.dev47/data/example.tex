\documentclass{article}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{mdframed}
\usepackage{minted}
\usepackage{verbatim}

\newenvironment{lcode}
  {\VerbatimEnvironment
   \begin{minted}[breaklines,fontsize=\footnotesize]{python}}
  {\end{minted}}
\BeforeBeginEnvironment{lcode}{\begin{mdframed}}
\AfterEndEnvironment{lcode}{\end{mdframed}}

% \newenvironment{lcode}{\verbatim}{\endverbatim}
% \BeforeBeginEnvironment{lcode}{\begin{minted}[breaklines,fontsize=\footnotesize]{python} }
% \AfterEndEnvironment{lcode}{\end{minted}}
% \BeforeBeginEnvironment{lcode}{\begin{mdframed}}
% \AfterEndEnvironment{lcode}{\end{mdframed}}

\newenvironment{lresult}{\verbatim}{\endverbatim}
\BeforeBeginEnvironment{lresult}{\begin{mdframed}}
\AfterEndEnvironment{lresult}{\end{mdframed}}

\newcommand{\linline}[2]{#2}

\graphicspath{ {./} }

\begin{document}

\section{Environment tags}

LitREPL treats specially named Latex environments as code and result sections.
It doesn't really evaluate \TeX\ commands so the tags should present in the source
file explicitly rather than be a result of other commands such as
\texttt{newcommand} or \texttt{newenvironment}.

\begin{verbatim}
\newenvironment{lcode}
  {\VerbatimEnvironment
   \begin{mdframed}
   \begin{minted}[breaklines, fontsize=\footnotesize]{python}}
  {\end{minted}
   \end{mdframed}}
\newenvironment{lresult}
  {\begin{mdframed}}
  {\end{mdframed}}
\newcommand{\linline}[2]{#2}
\end{verbatim}

\section{Executing code snippets}

\subsection{Regular output}

Executable code is obtained from the content of the \texttt{lcode} environment.
Putting the cursor on this environment and typing the \texttt{:LitEval1} Vim
command sends the code to the Python interpreter persistently running in the
background.

%lignore
\begin{verbatim}
\begin{lcode}
W='Value of \\textbf{W}!'
print(W)
\end{lcode}
\end{verbatim}
%lnoignore

\begin{lcode}
W='Value of \\textbf{W}!'
print(W)
\end{lcode}

\texttt{lresult} section next to the executable section is a result container.
When executed, LitREPL replaces its content with the executable code output.

%lignore
\begin{verbatim}
\begin{lresult}
PLACEHOLDER
\end{lresult}
\end{verbatim}
%lnoignore

\begin{lresult}
Value of \textbf{W}!
\end{lresult}

\subsection{Verbatim input and output}

VimREPL also recognises commented \texttt{lresult} tags as a valid result
container. This we can generate custom parts of the document.

%lignore
\begin{verbatim}
\begin{lcode}
print(W)
\end{lcode}
\begin{mdframed}
%lresult
PLACEHOLDER
%lnoresult
\end{mdframed}
\end{verbatim}
%lnoignore

\begin{lcode}
print(W)
\end{lcode}
\begin{mdframed}
%lresult
Value of \textbf{W}!
%lnoresult
\end{mdframed}

A less often used option of verbatim input is also supported

%lignore
\begin{verbatim}
%lcode
print(r'Value of \textbf{W}!')
%lnocode
\begin{lresult}
PLACEHOLDER
\end{lresult}
\end{verbatim}
%lnoignore

%lcode
print(r'Value of \textbf{W}!')
%lnocode
\begin{lresult}
Value of \textbf{W}!
\end{lresult}

\subsection{Inline code}

A special two-argument \texttt{linline} tag works both as an executable section
and as a result container. We expect it to be used to print the contents of
Python variables, so VimREPL wraps the executable portion with the additional
\texttt{print(\%s)} operator. On the Latex side, we define the tag to ignore its
first argument but pass the second one as-is.

%lignore
\begin{verbatim}
\begin{mdframed}\linline{W}{??}\end{mdframed}
\end{verbatim}
%lnoignore

\begin{mdframed}\linline{W}{Value of \textbf{W}!}\end{mdframed}

\section{Mathplotlib plots and other graphics}

\begin{lcode}
import numpy as np
import matplotlib.pyplot as plt
plt.close()
X=np.array(range(100))
plt.plot(X, np.sin(X/10))
path='_img.png'
plt.savefig(path)
\end{lcode}

%lignore
\begin{verbatim}
\begin{center}
\includegraphics[width=0.8\textwidth]{\linline{path}{?}}
\end{center}
\end{verbatim}
%lnoignore

\begin{center}
\includegraphics[width=0.8\textwidth]{\linline{path}{_img.png}}
\end{center}

\end{document}
