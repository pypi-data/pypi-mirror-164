# -*- coding: utf-8 -*-
"""
Created on Wed May 11 08:37:49 2022

@author: Antonio Bulgheroni (antonio.bulgheroni@ec.europa.eu)


"""
import logging
import os
import re
from datetime import datetime
from os.path import exists
from pathlib import Path

import elog
import markdown
import tifffile
import urllib3
import yaml
from PIL import Image
from PyQt5 import QtCore
from yattag import Doc, indent

from autologbook import autoconfig

urllib3.disable_warnings()
Signal = QtCore.pyqtSignal
Slot = QtCore.pyqtSlot
log = logging.getLogger('__main__')


class SignalDispatcher(QtCore.QObject):
    """
    Signal Dispatcher class.

    An helper class to implement the Qt Signal / Slot mechanism for non Qt derived
    object.

    """

    added_element = Signal(str, str, str, name='added_element')
    removed_element = Signal(str, str, str, name='removed_element')


class HTMLObject(object):
    """
    Subclass of Object just able to generate HTML code.

    it contains only the three **variable** of the yattag package.

    """

    # the yattag for HTML code generation
    doc, tag, text, line = Doc().ttl()

    # used for the proper construction of the URLs
    baseRFolder = autoconfig.IMAGE_SERVER_BASE_PATH  # Path('R:\A226\Results')
    rootFolder = autoconfig.IMAGE_SERVER_ROOT_URL  # 'https://10.166.16.24/micro'

    def convertPath2URI(self, path):
        """
        Convert a path to a URI.

        This utility takes an input path and it manipulates it in order to obtain
        a valid URL.

        First it removes the IMAGE_SERVER_BASE_PATH and replaces it with the
        IMAGE_SERVER_ROOT_URL (both values are taken from the autoconfig constants)
        and then it replaces all back-slashes with normal slashes.

        Parameters
        ----------
        path : Path-like object or string
            The input path to be converted.

        Returns
        -------
        url : URL
            The URL generated by the conversion.

        """
        p = Path(path)
        p_str = str(p)
        url = p_str.replace(str(self.baseRFolder), str(
            self.rootFolder)).replace('\\', '/')
        return url

    def printHTML(self, indentation=True):
        """
        Print the HTML content.

        Parameters
        ----------
        indentation : BOOL, optional
            Set to True to have indentation in the output (good for humans)
            Set to False for a plain and compact out (good for file).

        Returns
        -------
        Return a string of HTML

        """
        if indentation:
            return indent(self.doc.getvalue(), indentation='\t',
                          newline='\r\n', indent_text=True)
        else:
            return self.doc.getvalue()

    def saveHTML2File(self, filename, indentation=False):
        """
        Save th HTML to a file.

        Parameters
        ----------
        filename : File-like object
            The target file name
        indentation : BOOL, optional
            Set to True to have indentation in the output (good for humans)
            Set to False for a plain and compact out (good for file).

        Returns
        -------
        None.

        """
        log.debug('Saving HTML to file %s' % filename)
        with open(filename, 'w', encoding='utf-8') as fp:
            fp.write(self.printHTML(indentation))

    @classmethod
    def resetHTMLContent(cls):
        """
        Reset the HTML Content of the YATTAG doc.

        Returns
        -------
        None.

        """
        log.debug('Resetting the HTML Content')
        cls.doc, cls.tag, cls.text, cls.line = Doc().ttl()


class Protocol(HTMLObject):
    """
    The basic protocol class.

    it contains:
        - an empty list of samples
        - an empty list of attachments
        - a protocol number
        - a project name
        - a project responsible

    """

    def __init__(self, path):
        """
        Make an instance of Protocol.

        It tries to guess the protocol number,
        project name and responsible from the folder name

        the folder name should be something like this
        12458-Project-Responsible
        12458_Project_Responsible

        """
        HTMLObject.__init__(self)
        self.path = Path(path)
        folder = self.path.parts[-1]
        pattern = '^#*([\\d]+)\\s*[-_]\\s*([\\w\\W]+)\\s*[-_]\\s*([\\w\\W]+)$'
        match = re.search(pattern, folder)
        try:
            self.protocol = match.group(1)
            self.project = match.group(2)
            self.responsible = match.group(3)
            log.info('Created a new Protocol (#={}, Project={}, Responsible={})'
                     .format(self.protocol, self.project, self.responsible))
        except AttributeError:
            log.error(
                'Protocol parameters aren\'t available in the folder name ({}).'.format(folder))
            # TODO: implement a recovery for this situation

        # initialize empty list for attachments and samples.
        self.attachments = []
        # in the case of samples it must be a dictionary.
        self.samples = {}

        # initialize the patterns and the exclusion patterns
        self.patterns = ['*.tif*', '*.yaml', '*.yml']
        self.excludedPatterns = []

        # a signal dispatcher
        self.signal_dispatcher = SignalDispatcher()

    def emit_added(self, element_type, element_name, parent_name):
        """
        Emit a signal for the addition of a given element to the protocol.

        This method implments an interface to the Qt Signal / Slot mechanism.
        Every time a new element is added to the protocol, this method should be
        called in order to make the GUI aware of the changes, in particular
        the TreeViewModel where the whole protocol is described.

        Parameters
        ----------
        element_type : String
            A constant string identifying the type of element being added.
            The following values are implemented:
                - MicroPic: a MicroscopePicture
                - NavPic: a NavigationPicture
                - Sample: a Sample.
        element_name : String
            In the case of MicroPic and NavPic, the element_name must be the
            full path of the newly added element.
            In the case of Sample, the element_name is exactly the sample name
        parent_name : String
            In the case of NavPic, the parent_name is totally optional because
            all navigation images will be added to the 'Navigation Images' section.
            In the case of MicroPic, the parent_name is the sample name.
            In the case of Sample, the parent_name is totally optional because
            all new samples will be added to the 'Samples' section.

        Returns
        -------
        None.

        """
        self.signal_dispatcher.added_element.emit(
            element_type, element_name, parent_name)

    def emit_removed(self, element_type, element_name, parent_name):
        """
        Emit a signal for the removal of a given element from the protocol.

        This method implments an interface to the Qt Signal / Slot mechanism.
        Every time an element is removed from the protocol, this method should be
        called in order to make the GUI aware of the changes, in particular
        the TreeViewModel where the whole protocol is described.

        Parameters
        ----------
        element_type : String
            A constant string identifying the type of element being removed.
            The following values are implemented:
                - MicroPic: a MicroscopePicture
                - NavPic: a NavigationPicture
                - Sample: a Sample.
        element_name : String
            In the case of MicroPic and NavPic, the element_name must be the
            full path of the removed element.
            In the case of Sample, the element_name is exactly the sample name
        parent_name : String
            In the case of NavPic, the parent_name is totally optional because
            all navigation images are located in the 'Navigation Images' section.
            In the case of MicroPic, the parent_name is the sample name.
            In the case of Sample, the parent_name is totally optional because
            all samples are located in the 'Samples' section.

        Returns
        -------
        None.

        """
        self.signal_dispatcher.removed_element.emit(
            element_type, element_name, parent_name)

    def getPatterns(self):
        """
        Return the interesting patterns for the watchdog.

        Each type of logbook has its own list of patterns and ignore patterns

        Returns
        -------
        None.

        """
        return self.patterns

    def getExcludedPatterns(self):
        """
        Return the excluded patterns for the watchdog.

        Each type of logbook has its own list of patterns and ignore patterns

        Returns
        -------
        None.

        """
        return self.excludedPatterns

    def addAttachment(self, attachment_path):
        """
        Add an attachment at the Protocol.

        Parameters
        ----------
        attachment_path : PATH | string
            The path of the attachment file.

        Returns
        -------
        None.

        """
        self.attachments.append(attachment_path)
        log.info('Added {} to the attachment list'.format(
            os.path.split(attachment_path)[-1]))
        log.debug('New attachment full path is {}'.format(attachment_path))
        log.debug('At the moment there are {} attachments in the list'.format(
            len(self.attachments)))

    def removeAttachment(self, attachment_path):
        """
        Remove one attachment.

        Parameters
        ----------
        attachment_path : Path | String
            The path of the attachment file

        Returns
        -------
        None.

        """
        if attachment_path in self.attachments:
            self.attachments.remove(attachment_path)
            log.info('Removed {} to the attachment list'.format(
                os.path.split(attachment_path)[-1]))
            log.debug('Removed attachment full path is {}'.format(
                attachment_path))
            log.debug('At the moment there are {} attachments in the list'.format(
                len(self.attachments)))
        else:
            log.warning('Attempt to remove {} from the attachments list, but it was not there'.format(
                os.path.split(attachment_path)[-1]))

    def addSample(self, sample):
        """
        Add a new sample to the protocol.

        The sample name is guessed from the folder


        Parameters
        ----------
        sample : autologbook.Sample
            This is an instance of the autologbook.Sample.

        Returns
        -------
        None.

        """
        self.samples[sample.name] = sample
        self.emit_added('Sample', sample.name, 'Samples')
        sample.signal_dispatcher.added_element.connect(
            self.signal_dispatcher.added_element)
        sample.signal_dispatcher.removed_element.connect(
            self.signal_dispatcher.removed_element)
        log.info('Added {} to the sample list'.format(sample.name))
        log.debug('At the moment there are {} samples in the list'.format(
            len(self.samples)))

    def removeSample(self, sample):
        """
        Remove one sample.

        Parameters
        ----------
        sample : autologbook.Sample
            This is an instance of the autologbook.Sample.

        Returns
        -------
        None.

        """
        if self.samples[sample]:
            self.emit_removed('Sample', sample, 'Samples')
            del self.samples[sample]
            log.info('Removed {} from the sample list'.format(sample))
            log.debug('At the moment there are {} samples in the list'.format(
                len(self.samples)))
        else:
            log.warning(
                'Attempt to remove {} from the sample list, but it was not there'.format(sample))

    def generateCustomHTML(self, mainkey):
        """
        Generate custom HTML.

        Helper function to generate customized HTML code for a given section.
        The section is identified by the mainkey parameter.

        The user can provide via the YAML customization file or the GUI, additional
        test (markdown formatted) to be added to each section of the protocol.

        Parameters
        ----------
        mainkey : string
            The section of the HTML for which the customized HTML is being
            generated.

        Returns
        -------
        None.

        """
        subkey = 'Description'
        exkey = 'Extra'
        if mainkey in self.yamlDict.keys() and self.yamlDict[mainkey]:
            if subkey in self.yamlDict[mainkey].keys() and self.yamlDict[mainkey][subkey]:
                self.doc.asis(markdown.markdown(
                    self.yamlDict[mainkey][subkey]))
            if exkey in self.yamlDict[mainkey].keys():
                if self.yamlDict[mainkey][exkey]:
                    if len(self.yamlDict[mainkey][exkey]) > 0:
                        self.line('h3', 'Additional information')
                        self.doc.asis(markdown.markdown(
                            self.yamlDict[mainkey][exkey]))

    def generateHTML(self):
        """
        Generate the HTML code for the protocol.

        This function is calling a similar function for each of the main sections
        of the protocol.
            1. Introduction
            2. Samples
            3. Closure

        Returns
        -------
        None.

        """
        log.info('Generating HTML code for protocol {}'.format(self.protocol))
        self.generateHTMLIntro()
        self.generateHTMLSamples()
        self.generateHTMLClosure()

    def generateHTMLIntro(self):
        """
        Generate the introduction for the HTML output.

        It generates the following:
            1. The protocol title
            2. The customized introduction part
            3. The sample list

        Returns
        -------
        None.

        """
        log.debug('Generating HTML intro of protocol {}'.format(self.protocol))
        self.line('h1', 'Analysis protocol {}'.format(self.protocol),
                  style='text-align: center;', id='intro')
        self.generateCustomHTML('Introduction')

        # generate sample list
        self.generateHTMLSampleList()

    def generateHTMLSampleList(self):
        """
        Generate HTML Sample list.

        Generate a list with all the samples found in the protocol

        Returns
        -------
        None.

        """
        self.generateCustomHTML('Samples')
        log.debug('Generating HTML sample list')
        if len(self.samples):
            self.line(
                'h2', 'This analysis contains the following samples:', id='samplelist')
            with self.tag('ul'):
                for name, sample in self.samples.items():
                    with self.tag('li'):
                        with self.tag('a', href='#{}'.format(name)):
                            self.text(name)
                        self.text(' with {} images'.format(len(sample.images)))

    def generateHTMLSamples(self):
        """
        Generate the HTML code of the Samples section.

        If there are no samples, then it prints a no samples found message and quit.
        Otherwise, it prints a table with all the images for each of the samples.

        The HTML code generation for each image is done by the
        MicroscopePicture.generateHTMLCode method.

        Returns
        -------
        None.

        """
        if len(self.samples) == 0:
            self.doc.stag('hr')
            message = 'No samples found for this protocol'
            self.line('h2', message)
            log.debug(message)
        for name, sample in self.samples.items():
            if len(sample.images) == 0:
                self.doc.stag('hr')
                message = 'No microscope pictures found for {}'.format(name)
                self.line('h2', message)
                log.debug(message)
            else:
                with self.tag('p'):
                    self.doc.stag('hr')
                self.line(
                    'h2', 'Picture list for sample: {}'.format(name), id=name)
                self.generateCustomHTML(name)
                log.debug('Generating HTML code for sample {}'.format(name))
                self.line('a', 'Hide / show the picture list',
                          onclick='hideDiv(\'{}table\')'.format(name), href='javascript:void(0);')
                with self.tag('table', border=1, cellpaggind=1, cellspacing=1,
                              style='display:table; width:1200px; border-collapse:collapse',
                              id='{}table'.format(name)):
                    with self.tag('tbody'):
                        for key, image in sample.images.items():

                            if image.getID() in self.yamlDict:

                                ydict = self.yamlDict[image.getID()]
                            elif int(image.getID()) in self.yamlDict:
                                ydict = self.yamlDict[int(image.getID())]
                            else:
                                ydict = {}
                            image.generateHTMLCode(ydict)
                self.doc.stag('br')
                self.line('a', 'Go back to the sample list',
                          href='#samplelist')
                self.doc.stag('br')
                self.line('a', 'Go back home', href='#intro')

    def generateHTMLClosure(self):
        """
        Generate the HTML code for the closure of the protocol.

        It is useful to add here all javascript that needs to be referred from
        page elements.

        Returns
        -------
        None.

        """
        with self.tag('script'):
            self.doc.asis('''
                          function hideDiv(div_name) {
                              var x = document.getElementById(div_name);
                              if (x.style.display == "none") {
                                      x.style.display = "table";
                              } else {
                                  x.style.display = "none" ;
                             }
                         }
                        ''')


class ELOGProtocol(Protocol):
    """Subclass of Protocol having information about ELOG."""

    def __init__(self, path, elog_hostname, elog_port, elog_user, elog_password,
                 elog_use_ssl=True, elog_logbook=None):
        Protocol.__init__(self, path)
        self.elog_hostname = elog_hostname
        self.elog_port = elog_port
        self.elog_user = elog_user
        self.elog_password = elog_password
        self.elog_use_ssl = elog_use_ssl
        self.elog_logbook = elog_logbook

        # initialize the yaml engine for HTML customization
        self.initializeYAML()

        # initialize an empty dictionary for the ELOG attributes
        self.attributes = {}

        # set the elog instance to null
        self.elog_instance = ''

    def initializeYAML(self):
        """
        Initialize the YAML customization tool.

        It looks for a yaml file in the protocol folder named according to the
        rule protocol-xxxxx.yaml where xxxxx is the protocol-id.

        If none is found than a new empty one is created, otherwise it is safely
        loaded and its content transferred to the yamlDict

        Returns
        -------
        None.

        """
        # initializie the yamlDict
        self.yamlDict = {}

        # let's assume that there 1 yaml file named protocol-123456.yaml
        self.yamlFilename = Path(self.path) / \
            Path('protocol-%s.yaml' % self.protocol)
        if not self.yamlFilename.exists():
            log.info('No yaml file found, copying an empty one')
            with open(self.yamlFilename, 'w') as file:
                file.write('#empty yaml file')

        with open(self.yamlFilename, 'r') as file:
            self.yamlDict = yaml.safe_load(file)
            if not self.yamlDict:
                # the file might be empty, then we need to set is as a dictionary
                self.yamlDict = {}
        log.info('Loaded yaml file %s' % self.yamlFilename.name)

    def connect2ELOG(self):
        """
        Connect to the ELOG.

        This method is calling the elog.open function to generate an instance
        to the elog protocol.

        The elog.open itself is not checking whether the connection is valid or not,
        so to be sure we are actually getting a valid elog_instance, a real query to
        the elog (get_message_ids) is also performed.

        Returns
        -------
        elog_instance
            The elog_instance to be used to query the elog. The same value is
            also stored as an instance parameter

        """
        if self.elog_instance:
            return self.elog_instance
        log.info('Establishing connection with the eLOG server')
        try:
            # TODO: check how to pass encrypted password here
            self.elog_instance = elog.open(
                hostname=self.elog_hostname,
                port=self.elog_port,
                user=self.elog_user,
                password=self.elog_password,
                use_ssl=self.elog_use_ssl,
                logbook=self.elog_logbook
            )
            # the elog open doens't check if the connection is ok
            # while the get message_ids perform a real connection
            # TODO: find a better way to test if the connection is valid.
            #       this is probably to be done in the elog package.
            self.elog_instance.get_message_ids()
            log.info('Connection to the eLOG server successfully established')
            return self.elog_instance
        except Exception as err:
            log.critical(
                'Unable to establish a connection with the eLOG server. Here is the returned error message.' + err)

    def postELOGMessage(self, skipAttachements=False):
        """
        Post the protocol to the ELOG server.

        This method will do the following:
            1. Attempt a connection to the elog server
            2. Check if other entries with the same protocol number exist.
                2.1 If yes and if it is one, just delete it.
                2.2 If no, just go ahead.
                2.3 If yes and they are many, then raise an exception.
            3. Post a new entry with all the required attributes and the HTML
               content.


        Parameters
        ----------
        skipAttachements : Bool, optional
            Decide whether to post also attachment or not.
            Posting attachments maybe bandwidth heavy and it makes no sense
            while updating the protocol during the analysis. It is only meaningfull
            at the end of the analysis.
            The default is False.

        Raises
        ------
        NameError
            Exception raised when more than one entries with the same protocol
            number is found already existing in the elog.

        Returns
        -------
        None.

        """
        if not self.elog_instance:
            self.connect2ELOG()
        # check if an entry with the same protocol id already exists
        protocol_ids = self.elog_instance.search(
            {'Protocol ID': self.protocol})
        for eid in protocol_ids:
            log.debug('Entry %s with protocol %s' % (eid, self.protocol))
        log.debug('Searching for IDs with %s' % self.protocol)
        if (len(protocol_ids)) > 1:
            # there are more than 1 entry with this protocol ID. It is a problem. Ask the user what to do.
            # TODO: implement this situation
            log.warn(
                'Several protocols with the same IDs have been found {}'.format(protocol_ids))
            raise NameError

        # if an entry already exists, we delete it and create a new one
        if protocol_ids:
            try:
                self.elog_instance.delete(protocol_ids[0])
                log.debug('Found already an eLog entry with protocol {}. Deleting it'.format(
                    self.protocol))
            except elog.logbook_exceptions.LogbookError as e:
                log.exception('Logbook error', e)
        attachments = []
        if skipAttachements:
            attachments = []
        else:
            # please load only not empty attachments.
            for att in self.attachments:
                if os.stat(att).st_size:
                    attachments.append(att)
        try:
            self.elog_instance.post(self.printHTML(
                False), reply=False, attributes=self.attributes, attachments=attachments, encoding='HTML')
            log.info('Posting eLog entry for protocol {}'.format(self.protocol))
        except elog.logbook_exceptions.LogbookAuthenticationError as e:
            log.exception('Logbook error', e)


class QuattroELOGProtocol(ELOGProtocol):
    """
    Subclass of the ELOGProtocol dedicated to the Quattro Microscope.

    This subclass implements all the specificities of the Quattro in particular
    the presence of navigation camera images.

    """

    def __init__(self, path, elog_hostname, elog_port, elog_user, elog_password,
                 elog_use_ssl=True, elog_logbook=autoconfig.QUATTRO_LOGBOOK):

        ELOGProtocol.__init__(self, path, elog_hostname, elog_port, elog_user,
                              elog_password, elog_use_ssl=True,
                              elog_logbook=autoconfig.QUATTRO_LOGBOOK)
        self.navcamimages = []
        self.attributes = {
            'Protocol ID': self.protocol,
            'Project': self.project,
            'Customer': self.responsible,
            'Operator': elog_user,
            'Creation date': datetime.today().timestamp()
        }
        self.patterns.append('*NavCam*')  # add support for navcam images
        self.patterns.append('*.pdf')  # add support for pdf reports

        # exclude thumbnail and converted images
        self.excludedPatterns.append('png/*png')

    def generateHTMLIntro(self):
        """
        Overload the standard HTML introduction.

        This overloaded method allows to implement the specific HTML introduction
        for the Quattro microscope.

        It prints the following:
            1. Protocol Title
            2. Customized introduction taken from the YAML file
            3. Sample list
            4. Navigation camera section

        """
        log.debug('Generating HTML intro for protocol {}'.format(self.protocol))
        self.line('h1', 'Quattro SEM Analysis protocol {}'.format(
            self.protocol), style="text-align:center;", id='intro')
        self.generateCustomHTML('Introduction')
        self.generateHTMLSampleList()
        self.generateHTMLNavCam()

    def generateHTMLNavCam(self):
        """
        Generate the HTML code for the Navigation camera section.

        It prints the following:
            1. Section title if at least one navigation image is provided.
            2. Custom text provided via the YAML file
            3. A single column table with a navigation image per line


        Returns
        -------
        None.

        """
        log.debug('Generating HTML code for the navigation camera images of protocol {}'.format(
            self.protocol))
        if len(self.navcamimages) == 0:
            log.debug('No navigation picture provided!')
            self.line('h2', 'No navigation picture provided!')
        else:
            self.line('h2', 'Navigation Camera image(s)')
            self.generateCustomHTML('Navigation images')

            with self.tag('table', align='left', border='1', cellpadding='1', cellspacing='1',
                          style='float:none;width:%spx; border-collapse:collapse' % autoconfig.IMAGE_NAVIGATION_MAX_WIDTH):
                with self.tag('tbody'):
                    for navcamimage in self.navcamimages:
                        with self.tag('tr'):
                            with self.tag('td'):
                                with self.tag('p', style='text-align-center'):
                                    with self.tag('figure', klass='image'):
                                        with self.tag('figure'):
                                            with self.tag('a', href=self.convertPath2URI(navcamimage)):
                                                self.doc.stag('img', width=autoconfig.IMAGE_NAVIGATION_MAX_WIDTH - 10,
                                                              alt=os.path.split(
                                                                  navcamimage)[-1],
                                                              src=self.convertPath2URI(navcamimage))

                                            caption = os.path.split(
                                                navcamimage)[-1]
                                            if os.path.split(navcamimage)[-1] in self.yamlDict and self.yamlDict[os.path.split(navcamimage)[-1]]:
                                                if 'Caption' in self.yamlDict[os.path.split(navcamimage)[-1]]:
                                                    caption = self.yamlDict[os.path.split(
                                                        navcamimage)[-1]]['Caption']
                                            self.line('figcaption', caption)
                                self.generateCustomHTML(
                                    os.path.split(navcamimage)[-1])

    def addNavCam(self, path):
        """
        Add a navigation camera image at the Protocol.

        Parameters
        ----------
        path : path-like | string
            The path of the navigation image file.

        Returns
        -------
        None.

        """
        self.navcamimages.append(path)
        log.info('Added {} to the navcam list'.format(path))
        log.debug('At the moment there are {} pictures in the navcam list'.format(
            len(self.navcamimages)))
        self.emit_added('NavPic', str(path), 'Navigation Images')

    def removeNavCam(self, path):
        """
        Remove one navigation camera image file.

        Parameters
        ----------
        path : Path | String
            The path of the navigation image file.

        Returns
        -------
        None.

        """
        if path in self.navcamimages:
            self.navcamimages.remove(path)
            log.info('Removed {} to the navcam list'.format(path))
            log.debug('At the moment there are {} pictures in the navcam list'.format(
                len(self.navcamimages)))
            self.emit_removed('NavCam', path, 'Navigation Images')
        else:
            log.warning(
                'Attempt to remove {} from the navcam list, but it was not there'.format(path))

class VersaELOGProtocol(ELOGProtocol):
    """
    Subclass of the ELOGProtocol dedicated to the Versa Microscope.

    This subclass implements all the specificities of the Versa in particular
    the presence of navigation camera images.

    """

    def __init__(self, path, elog_hostname, elog_port, elog_user, elog_password,
                 elog_use_ssl=True, elog_logbook=autoconfig.VERSA_LOGBOOK):

        ELOGProtocol.__init__(self, path, elog_hostname, elog_port, elog_user,
                              elog_password, elog_use_ssl=True,
                              elog_logbook=autoconfig.VERSA_LOGBOOK)
        self.attributes = {
            'Protocol ID': self.protocol,
            'Project': self.project,
            'Customer': self.responsible,
            'Operator': elog_user,
            'Creation date': datetime.today().timestamp()
        }
        self.patterns.append('*.pdf')  # add support for pdf reports

        # exclude thumbnail and converted images
        self.excludedPatterns.append('png/*png')    

    def generateHTMLIntro(self):
        """
        Overload the standard HTML introduction.

        This overloaded method allows to implement the specific HTML introduction
        for the Versa microscope.

        It prints the following:
            1. Protocol Title
            2. Customized introduction taken from the YAML file
            3. Sample list

        """
        log.debug('Generating HTML intro for protocol {}'.format(self.protocol))
        self.line('h1', 'VERSA 3D FIB Analysis protocol {}'.format(
            self.protocol), style="text-align:center;", id='intro')
        self.generateCustomHTML('Introduction')
        self.generateHTMLSampleList()


class Sample(HTMLObject):
    """
    The basic class for sample analysis.

    It contains a list of MicroscopePictures

    """

    def __init__(self, name):
        # sample name, generally the folder where all its images are stored.
        self.name = name

        # signal dispatcher
        self.signal_dispatcher = SignalDispatcher()

        # self.images is a dictionary
        self.images = {}
        log.info('Created a new sample named {}'.format(self.name))

    def emit_added(self, element_type, element_name, parent_name):
        """
        Cause the signal dispatcher to emit an added_element signal.

        Parameters
        ----------
        element_type : String
            A constant string identifying the type of element being added.
            The following value is implemented:
                - MicroPic: a MicroscopePicture
        element_name : String
            In the case of MicroPic the element_name must be the
            full path of the added element.
        parent_name : String
            In the case of MicroPic, the parent_name is the sample name.

        Returns
        -------
        None.

        """
        self.signal_dispatcher.added_element.emit(
            element_type, element_name, parent_name)

    def emit_removed(self, element_type, element_name, parent_name):
        """
        Cause the signal dispatcher to emit an removed_element signal.

        Parameters
        ----------
        element_type : String
            A constant string identifying the type of element being removed.
            The following value is implemented:
                - MicroPic: a MicroscopePicture
        element_name : String
            In the case of MicroPic the element_name must be the
            full path of the removed element.
        parent_name : String
            In the case of MicroPic, the parent_name is the sample name.

        Returns
        -------
        None.

        """
        self.signal_dispatcher.removed_element.emit(
            element_type, element_name, parent_name)

    def addMicroscopePicture(self, microPic):
        """
        Add a microscope picture from the sample.

        Parameters
        ----------
        microPic : autoprotocol.MicroscopePicture
            The microscope picture to be added to the sample..

        Returns
        -------
        None.

        """
        microPic.thumbfile = microPic.generatePNG(
            autoconfig.IMAGE_SAMPLE_THUMB_MAX_WIDTH, 'thumb-png', forceRegen=False)
        microPic.pngfile = microPic.generatePNG(0, 'png', forceRegen=False)
        self.images[microPic.params['path']] = microPic
        self.emit_added('MicroPic', microPic.params['path'], self.name)
        log.info('Adding microscope picture ({}) to {}'.format(
            microPic.params['fileName'], self.name))
        log.debug('At the moment there are {} pictures in the sample {}'.format(
            len(self.images), self.name))

    def removeMicroscopePicturePath(self, path):
        """
        Remove a microscope picture using its path.

        Parameters
        ----------
        path : path-lile | string
            The full path of the microscope picture to be removed.

        Returns
        -------
        None.

        """
        try:
            self.removeMicroscopePicture(self.images[path])
        except KeyError:
            log.error(
                'Could not find an image with the following path %s' % str(path))

    def removeMicroscopePicture(self, microPic):
        """
        Remove a microscope picture from the sample.

        Parameters
        ----------
        microPic : autoprotocol.MicroscopePicture
            The microscope picture to be removed to the sample..

        Returns
        -------
        None.

        """
        if microPic.params['path'] in self.images:
            log.info('Removed {} from the image list'.format(
                microPic.params['fileName']))
            log.debug('At the moment there are {} pictures in the sample {}'.format(
                len(self.images), self.name))
            try:
                os.remove(microPic.pngfilename)
                os.remove(microPic.thumbfilename)
            except BaseException:
                log.warning('Not critical error removing converted PNG files')
            self.emit_removed('MicroPic', microPic.params['path'], self.name)
            del(self.images[microPic.params['path']])
        else:
            log.warning('Attempt to remove {} from sample {}, but it was not there'.format(
                microPic.params['fileName'], self.name))


class MicroscopePicture(HTMLObject):
    """
    The basic microscope picture class.

    This is actually a pure virtual class that need to be implement for each microscope type

    This basic class has an empty dictionary of parameters

    """

    def __init__(self, path=None, picType=None):
        """
        Construct a microscope picture.

        Parameters
        ----------
        path : str | path-like opject, optional
            The path to the image.

        picType : str, optional
            It corresponds to the type of image / microscope

        Returns
        -------
        None.

        """
        # initialize all the parameters dictionary
        self.params = dict()
        self.params['path'] = path
        self.params['picType'] = picType
        self.params['fileName'] = os.path.split(path)[-1]
        self.params['fileExt'] = os.path.splitext(os.path.split(path)[-1])[1]
        self.params['id'] = ''
        log.info('Created a new MicroscopePicture ({})'.format(
            self.params['fileName']))

    def getID(self):
        """
        Return the ID of the Microscope Picture.

        Returns
        -------
        ID
            The microscope picture ID.

        """
        return self.params['id']

    def getPicType(self):
        """
        Return the picture type.

        Returns
        -------
        picType : str
            The type of picture.

        """
        return self.params['picType']

    def getParameters(self):
        """
        Return the picture parameter dictionary.

        Returns
        -------
        The whole parameter dictionary

        """
        return self.params

    def getParameter(self, parName):
        """
        Return a specific parameter from the dictionary if it exists, None if it is not existing.

        Parameters
        ----------
        parName : String
            Parameter Name.

        Returns
        -------
        The value of the parameter or None if is not existing

        """
        try:
            return self.params[parName]
        except BaseException:
            return None

    def generatePNG(self, maxWidth=400, subfolder='png-thumb', forceRegen=False):
        """
        Generate a PNG version of a Microscope Picture.

        Parameters
        ----------
        maxWidth : integer, optional
            The horizontal size of the png image.
            Set to 0 to disable the scaling.
            The default is 400.
        subfolder : string, optional
            A relative directory to the sample where the generated PNG should be stored.
            The default is 'png-thumb'.
        forceRegen : bool, optional
            Force the regenaration of a PNG image even if it exists already.
            The default is False.

        Returns
        -------
        thumbfile : string
            The URI of the generated PNG file.

        """
        # save the file in a subfolder defined by subfolder
        # make the folder if it doesn't exist
        thumbpath = os.path.join(os.path.split(
            self.params['path'])[0], subfolder)
        if not os.path.exists(thumbpath):
            os.mkdir(thumbpath)
        thumbfilename = os.path.splitext(os.path.split(
            self.params['path'])[-1])[0] + '-{}.png'.format(subfolder)
        thumbfile = os.path.join(thumbpath, thumbfilename)

        if maxWidth == 0:
            self.pngfilename = thumbfile
            self.pngurl = self.convertPath2URI(thumbfile)
        else:
            self.thumbfilename = thumbfile
            self.thumburl = self.convertPath2URI(thumbfile)

        if not forceRegen and exists(thumbfile):
            log.debug('Skipping the generation of PNG for {} because already existing'.format(
                self.params['fileName']))

        else:
            if maxWidth == 0:
                log.info('Converting image {} in PNG format'.format(
                    self.params['fileName']))
            else:
                log.info('Generating thumbnail of {} with maxWidth {}'.format(
                    self.params['fileName'], maxWidth))
            with Image.open(self.params['path'], 'r') as image:
                w, h = image.size
                log.debug('Image size {} x {}'.format(w, h))
                if maxWidth > 0:
                    image.thumbnail((round(maxWidth), round(maxWidth * h / w)))
                image.convert('RGB')
                image.save(thumbfile, format='PNG')

        # the output filename is something like:
        #                R:\A226\Results\2022\12456-RADCAS-Bulgheroni\Graphite\png
        # but the webserver is:
        #               https://10.166.16.24/micro/2022/12456-RADCAS-Bulgheroni/Graphite/png
        #
        # so I need to replace 'R:\A226\Results\' with 'https://10.166.16.24/micro/'
        thumbfile = self.convertPath2URI(thumbfile)
        thumbfile = thumbfile.replace('\\', '/')

        return thumbfile


class FEIPicture(MicroscopePicture):
    """
    The basic FEI pictures.

    All relevant parameters for the logbook are taken from the TIFFfile and
    inserted in the parameter dictionary.

    """

    def __init__(self, path=None):
        MicroscopePicture.__init__(self, path)
        self.getTIFFFileTags()

    def getTIFFFileTags(self):
        """
        Get the TIFF file tags.

        Open the tifffile corresponding to the FEI picture using the tifffile
        library and get the fei_metadata dictionary.

        Relevant information for the logbook are transferred from the fei_metadata
        to the internal dictionary.

        The magnification is calculated starting from the display width and the
        horizontal field of view.

        Raises
        ------
        TypeError
            If the TIFF file is not a FEI image.

        Returns
        -------
        None.

        """
        path = self.params['path']

        with tifffile.TiffFile(path) as tif:

            # first really double check that this is a FEI image
            if not tif.is_fei:
                raise TypeError
            # for HV add kV if > 1000
            self.params['hv'] = (
                str(tif.fei_metadata['Beam']['HV']) + 'V',
                str(round(tif.fei_metadata['Beam']['HV'] / 1000)) + 'kV'
            )[tif.fei_metadata['Beam']['HV'] > 1000]

            self.params['beam'] = tif.fei_metadata['Beam']['Beam']
            self.params['hfw'] = tif.fei_metadata[self.params['beam']]['HFW']
            self.params['dispwidth'] = tif.fei_metadata['System']['DisplayWidth']
            # for magnification there is a mystery 1.25 scale factor
            # add kx if > 1000
            self.params['magnification'] = (
                str(round(self.params['dispwidth']
                    / self.params['hfw'] / 1.25)) + 'x',
                str(round(self.params['dispwidth']
                    / self.params['hfw'] / 1.25 / 1000)) + 'kx'
            )[round(self.params['dispwidth'] / self.params['hfw'] / 1.25) > 1000]
            self.params['spotsize'] = tif.fei_metadata['Beam']['Spot']
            self.params['detector'] = str(
                tif.fei_metadata['Detectors']['Mode']) + '.' + str(tif.fei_metadata['Detectors']['Name'])
            self.params['vacuum'] = str(tif.fei_metadata['Vacuum']['UserMode'])
            self.params['userText'] = str(tif.fei_metadata['User']['UserText'])
            self.params['width'] = tif.fei_metadata['Image']['ResolutionX']
            self.params['height'] = tif.fei_metadata['Image']['ResolutionY']
            self.params['resolution'] = (tif.fei_metadata['Image']['ResolutionX'],
                                         tif.fei_metadata['Image']['ResolutionY'])
            self.params['resolutionPrint'] = '({} x {})'.format(tif.fei_metadata['Image']['ResolutionX'],
                                                                tif.fei_metadata['Image']['ResolutionY'])
        for key in self.params:
            log.debug('{}  --> {}'.format(key, self.params[key]))


    def generateHTMLCode(self, yamlDict):
        """
        Generate the HTML code corresponding to the FEI image .

        Parameters
        ----------
        yamlDict : dictionary
            A dictionary containing the customized fields.

        Returns
        -------
        None.

        """
        log.debug('Generating HTML of picture {}'.format(
            self.getParameter('FileName')))

        with self.tag('tr'):
            with self.tag('td', colspan=5, style='text-align:center;height:50px;background-color:cyan'):
                self.line('b', self.params['path'])
            with self.tag('td', style='text-align:center;height:50px;background-color:cyan'):
                self.line('a', 'PNG', href=self.pngurl)
            with self.tag('td', style='text-align:center;height:50px;background-color:cyan'):
                self.line('a', 'TIFF', href=self.params['path'].replace(str(
                    autoconfig.IMAGE_SERVER_BASE_PATH), autoconfig.IMAGE_SERVER_ROOT_URL).replace('\\', '/'))
        with self.tag('tr'):
            with self.tag('th', colspan=2, rowspan=2):
                with self.tag('figure', klass='image'):
                    with self.tag('a', href=self.pngurl):
                        self.doc.stag('img', width=autoconfig.IMAGE_SAMPLE_THUMB_MAX_WIDTH - 10,
                                      alt=os.path.split(self.pngurl)[-1], src=self.thumburl)
                    caption = os.path.split(self.params['path'])[-1]
                    if 'Caption' in yamlDict and yamlDict['Caption']:
                        caption = yamlDict['Caption']
                    self.line('figcaption', caption)
            with self.tag('td'):
                self.line('strong', 'ID: ')
                self.text(self.params['id'])
            with self.tag('td'):
                self.line('strong', 'HV: ')
                self.text(self.params['hv'])
            with self.tag('td'):
                self.line('strong', 'Beam: ')
                self.text(self.params['beam'])
            with self.tag('td'):
                self.line('strong', 'Magnification: ')
                self.text(self.params['magnification'])
            with self.tag('td'):
                self.line('strong', 'Resolution: ')
                self.text(self.params['resolutionPrint'])
        with self.tag('tr'):
            with self.tag('td'):
                self.line('strong', 'Spot size: ')
                self.text(self.params['spotsize'])
            with self.tag('td'):
                self.line('strong', 'Detector: ')
                self.text(self.params['detector'])
            with self.tag('td'):
                self.line('strong', 'Vacuum: ')
                self.text(self.params['vacuum'])
            with self.tag('td'):
                self.line('strong', 'User text: ')
                self.text(self.params['userText'])
            with self.tag('td'):
                self.line('strong', 'Filename: ')
                self.text(os.path.split(self.params['path'])[-1])

        subkey = 'Description'
        exkey = 'Extra'
        if subkey in yamlDict:
            with self.tag('tr'):
                with self.tag('td', colspan=7):
                    self.doc.asis(markdown.markdown(yamlDict[subkey]))
        if exkey in yamlDict:
            if len(yamlDict[exkey]) > 0:
                with self.tag('tr'):
                    with self.tag('td', colspan=7):
                        self.line('h3', 'Additional information')
                        self.line('p', yamlDict[exkey])


class QuattroFEIPicture(FEIPicture):
    """
    Quattro Pictures, a subclass of FEI.

    Quattro images should be named according to this convention:

        id-samplename-someproperties.tif

    The name file is parsed against a regular expression and the picture id is stored
    in the parameters dictionary.

    """

    def __init__(self, path=None):
        FEIPicture.__init__(self, path)
        self.params['picType'] = 'FEI.Quattro'

        pattern = '^([0-9]+)[\\w\\W]*$'
        match = re.search(pattern, self.params['fileName'])
        try:
            self.params['id'] = match.group(1)
        except AttributeError:
            log.warning('Picture ID was not found in the file name ({}). Assigning ID = 0.'.format(self.params['fileName'])
                        + ' Remember to put the ID as first item in the filename!')
            self.params['id'] = 0

class VersaFEIPicture(FEIPicture):
    """
    Versa Pictures, a subclass of FEI.

    Quattro images should be named according to this convention:

        samplename-someproperties_id.tif

    The name file is parsed against a regular expression and the picture id is stored
    in the parameters dictionary.

    """
    
    def __init__(self, path=None):
        FEIPicture.__init__(self, path)
        self.params['picType'] = 'FEI.Versa'

        pattern = '^[\\w\\W]*[-_]([0-9]+).[\\w\\W]*$'
        match = re.search(pattern, self.params['fileName'])
        try:
            self.params['id'] = match.group(1)
        except AttributeError:
            log.warning('Picture ID was not found in the file name ({}). Assigning ID = 0.'.format(self.params['fileName'])
                        + ' Remember to put the ID as last item in the filename!')
            self.params['id'] = 0