# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: array_shape.proto, binary_op.proto, binary_var.proto, number_lit.proto, element.proto, jagged_array.proto, unary_op.proto, reduction_op.proto, integer_var.proto, placeholder.proto, subscript_op.proto, expression.proto, forall.proto, constraint.proto, penalty.proto, problem.proto, header.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import List

import betterproto


class BinaryOpKind(betterproto.Enum):
    UNKNOWN = 0
    ADD = 1
    MUL = 2
    DIV = 3
    POW = 4
    MOD = 5
    RANGE = 6
    EQ = 7
    NOT_EQ = 8
    LESS_THAN = 9
    LESS_THAN_EQ = 10
    AND = 11
    OR = 12
    XOR = 13


class NumberLitType(betterproto.Enum):
    UNKNOWN = 0
    FLOAT = 1
    INTEGER = 2


class JaggedArrayType(betterproto.Enum):
    UNKNOWN = 0
    FLOAT = 1
    INTEGER = 2


class UnaryOpKind(betterproto.Enum):
    UNKNOWN = 0
    ABS = 1
    CEIL = 2
    FLOOR = 3
    LOG2 = 4


class ReductionOpKind(betterproto.Enum):
    UNKNOWN = 0
    SUM = 1
    PROD = 2


class PlaceholderType(betterproto.Enum):
    UNKNOWN = 0
    FLOAT = 1
    INTEGER = 2


class PlaceholderShapeElement(betterproto.Enum):
    DYNAMIC = 0
    EXPRESSION = 1


class ProblemSense(betterproto.Enum):
    MIN = 0
    MAX = 1


@dataclass
class ArrayShape(betterproto.Message):
    axis: int = betterproto.uint64_field(1)


@dataclass
class BinaryOp(betterproto.Message):
    kind: "BinaryOpKind" = betterproto.enum_field(1)


@dataclass
class BinaryVar(betterproto.Message):
    symbol: str = betterproto.string_field(1)
    dim: int = betterproto.uint64_field(2)


@dataclass
class NumberLit(betterproto.Message):
    type: "NumberLitType" = betterproto.enum_field(1)
    value: int = betterproto.uint64_field(2)


@dataclass
class Element(betterproto.Message):
    symbol: str = betterproto.string_field(1)


@dataclass
class JaggedArray(betterproto.Message):
    type: "JaggedArrayType" = betterproto.enum_field(1)
    symbol: str = betterproto.string_field(2)
    dim: int = betterproto.uint64_field(3)


@dataclass
class UnaryOp(betterproto.Message):
    kind: "UnaryOpKind" = betterproto.enum_field(1)


@dataclass
class ReductionOp(betterproto.Message):
    kind: "ReductionOpKind" = betterproto.enum_field(1)
    has_condition: bool = betterproto.bool_field(2)


@dataclass
class IntegerVar(betterproto.Message):
    symbol: str = betterproto.string_field(1)
    dim: int = betterproto.uint64_field(2)


@dataclass
class Placeholder(betterproto.Message):
    type: "PlaceholderType" = betterproto.enum_field(1)
    symbol: str = betterproto.string_field(2)
    dim: int = betterproto.uint64_field(3)
    shape: List["PlaceholderShapeElement"] = betterproto.enum_field(4)


@dataclass
class SubscriptOp(betterproto.Message):
    num_subs: int = betterproto.uint64_field(1)


@dataclass
class Expression(betterproto.Message):
    id: str = betterproto.string_field(1)
    kind: "NodeKind" = betterproto.message_field(2)
    children: List["Expression"] = betterproto.message_field(3)


@dataclass
class NodeKind(betterproto.Message):
    number_lit: "NumberLit" = betterproto.message_field(1, group="kind")
    array_shape: "ArrayShape" = betterproto.message_field(2, group="kind")
    element: "Element" = betterproto.message_field(3, group="kind")
    jagged_array: "JaggedArray" = betterproto.message_field(4, group="kind")
    unary_op: "UnaryOp" = betterproto.message_field(5, group="kind")
    binary_op: "BinaryOp" = betterproto.message_field(6, group="kind")
    reduction_op: "ReductionOp" = betterproto.message_field(7, group="kind")
    binary_var: "BinaryVar" = betterproto.message_field(8, group="kind")
    integer_var: "IntegerVar" = betterproto.message_field(9, group="kind")
    placeholder: "Placeholder" = betterproto.message_field(10, group="kind")
    subscript_op: "SubscriptOp" = betterproto.message_field(11, group="kind")


@dataclass
class Forall(betterproto.Message):
    element: "Expression" = betterproto.message_field(1)
    condition: "Expression" = betterproto.message_field(2)


@dataclass
class Constraint(betterproto.Message):
    id: str = betterproto.string_field(1)
    name: str = betterproto.string_field(2)
    expression: "Expression" = betterproto.message_field(3)
    forall: List["Forall"] = betterproto.message_field(4)
    left_lower: "Expression" = betterproto.message_field(5)
    is_penalty: bool = betterproto.bool_field(6)
    needs_multiplier: bool = betterproto.bool_field(7)
    needs_square: bool = betterproto.bool_field(8)


@dataclass
class Penalty(betterproto.Message):
    id: str = betterproto.string_field(1)
    name: str = betterproto.string_field(2)
    expression: "Expression" = betterproto.message_field(3)
    forall: List["Forall"] = betterproto.message_field(4)
    needs_multiplier: bool = betterproto.bool_field(5)


@dataclass
class Problem(betterproto.Message):
    id: str = betterproto.string_field(1)
    name: str = betterproto.string_field(2)
    sense: "ProblemSense" = betterproto.enum_field(3)
    objective: "Expression" = betterproto.message_field(4)
    constraints: List["Constraint"] = betterproto.message_field(5)
    penalties: List["Penalty"] = betterproto.message_field(6)


@dataclass
class Header(betterproto.Message):
    id: str = betterproto.string_field(1)
    version: str = betterproto.string_field(2)
    value: "AttributeValue" = betterproto.message_field(3)


@dataclass
class AttributeValue(betterproto.Message):
    problem: "Problem" = betterproto.message_field(1, group="value")
    expression: "Expression" = betterproto.message_field(2, group="value")
