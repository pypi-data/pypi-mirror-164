import numpy as np
from _typeshed import Incomplete
from edgeiq.edge_tools import to_json_serializable as to_json_serializable
from typing import Any, Callable, Dict, List, Optional, Tuple, Type, TypeVar

DEFAULT_DEREGISTER_FRAMES: int
DEFAULT_MAX_DISTANCE: int
DEFAULT_MIN_INERTIA: int
DEFAULT_HISTORY_LENGTH: int
PredictionT = Any
TrackablePredictionT = TypeVar('TrackablePredictionT', bound='TrackablePrediction')
TrackerCbT = Callable[[int, TrackablePredictionT], None]
tracker_init_id: int
tracker_id: int

def get_tracker_init_id(): ...
def get_tracker_id(): ...

class TrackablePrediction:
    prediction: Incomplete
    deregister_frames: Incomplete
    min_inertia: Incomplete
    tid: Incomplete
    inertia: int
    disappeared_frames: int
    def __init__(self, prediction: PredictionT, deregister_frames: int, min_inertia: int, history_length: int, enter_cb: Optional[TrackerCbT] = ..., exit_cb: Optional[TrackerCbT] = ...) -> None: ...
    def step(self, **kwargs) -> None: ...
    def handle_found(self, prediction: PredictionT): ...
    def handle_disappeared(self) -> None: ...
    def handle_removed(self) -> None: ...
    @property
    def is_initialized(self) -> bool: ...
    @property
    def is_lost(self) -> bool: ...
    @property
    def history(self) -> list: ...
    @property
    def label(self) -> Optional[str]: ...
    @label.setter
    def label(self, label: str): ...
    @property
    def index(self) -> Optional[int]: ...
    @property
    def box(self) -> Optional[Any]: ...
    @property
    def confidence(self) -> Optional[float]: ...

class TrackingResults(dict):
    def __init__(self, objects: Dict[int, TrackablePredictionT], tracking_algorithm: str) -> None: ...
    @property
    def tracking_algorithm(self): ...

RESULT_TYPE: Incomplete

def match_greedy(dist: np.ndarray) -> List[Tuple[int, int]]: ...
def match_optimal(dist: np.ndarray) -> List[Tuple[int, int]]: ...
DistanceFunctionT = Callable[[TrackablePredictionT, PredictionT], float]
MatchOptimizerT: Incomplete

class TrackerAlgorithm:
    def __init__(self, deregister_frames: int, min_inertia: int, history_length: int, enter_cb: Optional[TrackerCbT], exit_cb: Optional[TrackerCbT], trackable: Type[TrackablePredictionT], distance_function: DistanceFunctionT, match_optimizer: MatchOptimizerT) -> None: ...
    def update(self, predictions: List[PredictionT], **trackable_kwargs) -> TrackingResults: ...
    def remove_id(self, id: int): ...
